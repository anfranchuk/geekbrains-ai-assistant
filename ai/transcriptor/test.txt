{'timecode_with_text': [[0.0, 11.5, ' Друзья, привет! С вами снова я Денис. Рад вас приветствовать на лекции. Сегодня мы будем говорить о массивах.'], [11.5, 19.5, ' На прошлой лекции мы познакомились с языком программирования C-sharp, с его основными характеристиками, а также решили блок базовой задачи.'], [19.5, 28.0, ' На семинарах вы попрактиковались в разработке циклических условных конструкций, применяли арифметические операторы, а также операции водовывода.'], [28.0, 37.0, ' Сегодня мы вспомним основные понятия, связанные с массивами, их характеристики, поговорим о том, в каких задачах массивы могут применяться.'], [37.0, 45.5, ' Познакомимся, как осуществляется операция создания, заполнения, а также вывода массивов на экран и решим блок задач на их обработку.'], [45.5, 57.0, ' Ближе к концу лекции мы познакомимся с двумя разновидностями циклов FOR и FORGE, а также, друзья, поговорим о таком важном аспекте, как изучение английского для программистов.'], [57.0, 66.0, ' Друзья, перед тем как приступить к практике и начать решать задачи, давайте вспомним, а что из себя представляет массив и какими характеристиками он обладает.'], [66.0, 69.0, ' Начнем с ключевого термина этой лекции – массив.'], [69.0, 76.0, ' Массив представляет собой структуру данных, которая преднадачена для хранения элементов, как правило, одного типа.'], [76.0, 83.0, ' Массив может состоять из целых чисел, вещественных, может состоять из символов, а также, например, из строк.'], [83.0, 95.0, ' Если приводить примеры из реальной жизни, то массива мы можем назвать упорядоченный набор инструментов или же набор елочных игрушек, которые также обладают характеристикой упорядоченности.'], [95.0, 98.0, ' Второй важный термин – это индекс элемента массива.'], [98.0, 104.0, ' Друзья, этот термин можно сформулировать по-разному, приведем наиболее популярные формулировки.'], [104.0, 114.0, ' Итак, первое – это смещение элемента относительно начала массива, то есть насколько позиции элемент смещен относительно его левой границы.'], [114.0, 119.0, ' Ну и вторая формулировка, наиболее простая, это просто позиция элемента массива.'], [119.0, 125.0, ' Друзья, напомню, что в большинстве языков программирования индекс массива начинается с нуля.'], [125.0, 128.0, ' Перейдем к основным характеристикам массивов.'], [128.0, 134.0, ' Первая характеристика – это то, что массив должен иметь имя, еще его называют идентификатор.'], [134.0, 138.0, ' С помощью имени мы осуществляем обращение к элементам массива.'], [138.0, 146.0, ' Если нам нужно изменить элемент или же просто его прочитать, то мы используем операцию обращения к элементам по индексу.'], [146.0, 148.0, ' Также, друзья, эту операцию называют индексация.'], [148.0, 153.0, ' В большинстве языков программирования она обозначается с помощью пары квадратных скобок.'], [153.0, 162.0, ' В примере приведен массив из пяти элементов, и ниже вы можете видеть обращение к каждому его элементу с помощью оператора квадратной скобки.'], [162.0, 166.0, ' Отметим важную характеристику, которая определяет внутреннее устройство массивов.'], [166.0, 175.0, ' Друзья, элементы в массиве располагаются последовательно, то есть в памяти они занимают ячейку за ячейкой.'], [175.0, 181.0, ' Ни в коем случае элементы в массиве не расположены хаотично или же в каком-либо другом порядке.'], [181.0, 188.0, ' Ну и в заключение добавим, что массивы имеют конечный размер, поскольку объем памяти у нас всегда ограничен.'], [188.0, 197.0, ' Итак, после небольшого экскурса в теорию давайте посмотрим, как будут выглядеть основные операции при работе с массивами на языке C-sharp.'], [197.0, 202.0, ' Рассмотрим создание, заполнение и вывод массива на экран.'], [202.0, 207.0, ' В языке C-sharp создание массива состоит из трех основных этапов.'], [207.0, 211.0, ' Первый этап – это указание типа данных для элемента массива.'], [211.0, 219.0, ' Также, друзья, мы указываем оператор квадратной скобки, чтобы показать, что у нас именно создается массив, а не обычная переменная.'], [219.0, 224.0, ' Второй этап – это указание идентификатора или же имени массива.'], [224.0, 229.0, ' В данном примере, друзья, мы пользуемся именем R, что является сокращением от array.'], [229.0, 233.0, ' Друзья, рекомендую давать массивам осмысленные имена.'], [233.0, 240.0, ' В самом простом случае можно дать имя array, однако рекомендую задуматься над более осмысленным именованием.'], [240.0, 247.0, ' Как в пределных примерах, если вы оперируете набором файлов, то такой массив можно назвать именем files.'], [247.0, 260.0, ' Если же вы оперируете набором среднесуточных температур, то подобный массив можно назвать average dilated temperatures или сократить до average dilated temps.'], [260.0, 269.0, ' Но здесь важно не злоупотреблять сокращением в именовании переменных, особенно если эти имена становятся необщепринятыми и необщеизвестными.'], [269.0, 279.0, ' Имена array, R вполне допустимы для учебных задач, где мы делаем упор на демонстрацию той или иной техники по обработке массивов.'], [279.0, 283.0, ' То есть акцент делается не на конкретной предметной области.'], [283.0, 287.0, ' Следующий этап – это выделение памяти от элемента массива.'], [287.0, 298.0, ' На данном этапе мы указываем количество элементов, а также используем оператор new, который нам выделит фрагмент памяти для хранения будущих элементов.'], [298.0, 305.0, ' На этом три основные операции по созданию массива закончены, но также, друзья, можно выделить и четвертый этап.'], [305.0, 315.0, ' Он заключается в связывании участков памяти, который мы выделили с помощью оператора new с именем массива, с помощью оператора присваивания.'], [315.0, 318.0, ' Работать сегодня мы будем в каталоге урок 2.'], [318.0, 321.0, ' Друзья, иерархия каталогов на сегодня у меня уже создана.'], [321.0, 330.0, ' Перейдем в каталог с заданием 1 и создадим там проект, знакомый вам командой .NET New Console.'], [330.0, 338.0, ' Перейдем в файл с исходным кодом program.cs, удалим код, который сгенерировался по умолчанию.'], [338.0, 345.0, ' Итак, укажем тип данных массив целых чисел.'], [345.0, 354.0, ' Далее дадим массиву имя, например, и имя, который мы будем использовать для создания код.'], [355.0, 364.0, ' Друзья, если был бы у нас массив вещественных чисел, то в этом случае мы слева изменили и выделили их.'], [364.0, 368.0, ' И мы будем использовать их для создания код.'], [368.0, 374.0, ' Друзья, если вы хотите сделать такой массив, то вы можете сделать такой массив.'], [374.0, 391.0, ' Друзья, если был бы у нас массив вещественных чисел, то в этом случае мы слева от присваивания да и справа от присваивания использовали бы тип данных double или же float.'], [391.0, 397.0, ' Друзья, после выполнения данной операции у нас будет создан массив на 5 целых чисел.'], [397.0, 402.0, ' Обращаться к нему мы можем, используя его имя.'], [403.0, 410.0, ' Отмечу, что в языке C sharp элементы при создании массива имеют значение по умолчанию.'], [410.0, 414.0, ' Если это числовой массив, то элементами являются нули.'], [414.0, 418.0, ' Далее заполним массив произвольными целыми числами.'], [418.0, 424.0, ' Напомним, друзья, что для изменения элементов массива мы используем оператор индексации.'], [424.0, 427.0, ' И в квадратных скобках указываем индекс элемента.'], [427.0, 430.0, ' Заполним его произвольными целыми числами.'], [430.0, 435.0, ' Для ускорения можно скопировать эти конструкции.'], [439.0, 444.0, ' И не забываем менять индексы массива.'], [446.0, 452.0, ' В данном случае они у нас изменяются от нулевого и до размера массива минус 1.'], [452.0, 457.0, ' Сделаем элементы массива относительно случайными.'], [460.0, 463.0, ' Проверим, действительно ли массив заполнен.'], [463.0, 470.0, ' Для этого выведем каждый элемент на экран знакомым методом в WriteLine из модуля консолы.'], [473.0, 478.0, ' Для вывода элементов, для обращения мы также используем имя массива.'], [478.0, 483.0, ' И операция индексации с указанием индекса необходимого нам элемента.'], [483.0, 489.0, ' Для ускорения конструкцию вывода можно скопировать необходимое количество раз.'], [489.0, 494.0, ' Заменив индексы на соответствующих позициях.'], [494.0, 499.0, ' Друзья, выполним наш код с помощью команды .NETRUN.'], [499.0, 503.0, ' На экране мы видим значения которые были помещены в массив.'], [503.0, 509.0, ' Друзья, а как вы думаете, что произойдет если мы обратимся к элементу index.im.'], [509.0, 515.0, ' Вега oben находится значениеpielный и на экране построено значение mashed.'], [515.0, 519.0, ' Heaven,oles Neil у нас цKelly.'], [519.0, 524.0, ' И на экране мы видим значения которые были помещены в массив.'], [524.0, 529.14, ' А как вы думаете, что произойдет, если мы обратимся к элементу с индексом 5,'], [529.14, 535.9, ' при том, что количество элементов в массиве равно 5? Давайте это проверим и попробуем вывести на'], [535.9, 542.1, ' экран элемент с индексом равным 5. Итак, воспользуемся все тем же методом консоли Brightline'], [542.1, 552.7, ' и выведем на экран массив с индексом равным 5. Сохраним исходный код и запустим наш проект еще раз.'], [552.7, 566.1800000000001, ' Друзья, обратите внимание, что на экране у нас вывелась ошибка, связанная с выходом за границы'], [566.1800000000001, 571.8000000000001, ' массива. То есть таким образом среда выполнения предупреждает нас о том, что недопустимо'], [571.8000000000001, 579.5400000000001, ' обращаться за границы памяти, который мы выделили для массива. Закомментируем строчку с'], [579.54, 586.86, ' недопустимым обращением к массиву и давайте продолжим. Итак, друзья, мы создали массив на 5'], [586.86, 592.2199999999999, ' элементов, заполнили его числами и вывели их на экран. Давайте рассмотрим способ заполнения массива'], [592.2199999999999, 599.4599999999999, ' сразу же при его создании. Для этого воспользуемся той же конструкцией, которую мы использовали,'], [599.4599999999999, 605.9399999999999, ' только с небольшим изменением. Все также будем создавать массив целочисленный. Дадим ему имя'], [605.94, 618.0600000000001, ' R2, поскольку имя R уже занято. И после указания имени выделим память на все те же 5 элементов,'], [618.0600000000001, 629.34, ' обязательно с указанием типа данных, и заполняем их произвольными целыми числами сразу же при'], [629.34, 639.62, ' создании этого массива. Друзья, напомню, что редактор Vizho Studio Code имеет инструменты'], [639.62, 646.98, ' форматирования кода. Для этого можно выделить необходимый участок, нажать правой кнопкой мыши'], [646.98, 654.6600000000001, ' и выбрать пункт меню формат документ или сочетание горячих клавиш shift alt f. Отмечу,'], [654.66, 660.54, ' что в C-sharp можно использовать упрощенный синтаксист для создания массива. Он заключается в том,'], [660.54, 667.26, ' что команду на выделение памяти, то есть new int и указание количества элементов,'], [667.26, 674.2199999999999, ' в некоторых случаях можно не использовать. Например, создадим целочисленный массив,'], [674.22, 690.7, ' дадим ему имя Ray3 и заполним его 5 целыми числами. Друзья, в этом случае команду на выделение'], [690.7, 697.5, ' памяти мы можем не использовать, поскольку число элементов у нас фиксировано и мы их указываем'], [697.5, 703.14, ' сразу при создании массива. Способ достаточно удобный для создания небольших массивов,'], [703.14, 710.86, ' когда заранее известные элементы. Друзья, отмечу, что, вероятно, знакомый многим из вас язык'], [710.86, 717.9, ' программирования Python имеет схожий синтаксис создания массива. Выглядит он примерно следующим образом.'], [717.9, 736.78, ' И также отмечу, что тип данных у массива мы не указываем. Не забываем, друзья,'], [736.78, 745.8199999999999, ' форматировать наш код, чтобы повысить его читаемость. Сохраним наши наработки в репозитории'], [745.82, 764.1, ' edit, проиндексируем целиком каталог task1, далее сформируем commit с указанием комментария о том,'], [764.1, 779.46, ' что мы добавили первую задачу в уроке 2 и отправим наши наработки на удаленный репозиторий.'], [794.1, 801.94, ' Друзья, перед тем как приступить к решению задач, давайте поговорим о том, а какие именно классы'], [801.94, 808.7, ' задач могут быть решены с помощью массивов, а также каким специальностям навыки работы с'], [808.7, 815.38, ' массивами и в целом знание о слов программирования будет полезным. Один из самых простых вариантов'], [815.38, 822.5, ' использования это хранение однотипных элементов и последующее обращение к ним. Например, в массиве'], [822.5, 828.38, ' мы можем сохранить набор целых чисел, чисел с плавающей точкой, символов или же набор строк,'], [828.38, 833.78, ' которые составляют некоторый текст. Также в массиве можем сохранить и более сложные объекты,'], [833.78, 839.54, ' например файлы. Массивы часто используются для поиска элементов по какому-либо критерию.'], [839.54, 845.1, ' Например, знакомый вам поиск минимального и максимального значения среди набора целых'], [845.1, 852.66, ' чисел. Если же рассмотреть набор строк в виде имен файлов как массив, то в таком массиве мы'], [852.66, 858.1800000000001, ' можем осуществить поиск графических файлов, файлов с видео содержимым или же, например,'], [858.1800000000001, 865.5, ' файлов с исходным кодом. В данном случае критерием будет расширение файла. Также отметим класс задач,'], [865.5, 871.1800000000001, ' в которых необходимо вычислить некоторую характеристику от всего набора элементов.'], [871.18, 878.5799999999999, ' Это может быть сумма значений, это может быть произведение или среднее значение. Друзья,'], [878.5799999999999, 885.0999999999999, ' в качестве примера можно рассмотреть вычисления суммарных затрат на предприятии. В таком массиве'], [885.0999999999999, 890.9399999999999, ' элементами могут быть затраты предприятия за день, за неделю или же, например, за месяц.'], [890.9399999999999, 897.9399999999999, ' Друзья, вопрос на засыпку. А как вы думаете, какой тип данных может быть у элементов в подобном'], [897.94, 904.5400000000001, ' массиве? Свои предположения можете написать в чат. Второй пример — это нахождение средней'], [904.5400000000001, 911.3000000000001, ' температуры за год. В таком массиве элементами могут быть значения температур за месяц, из'], [911.3000000000001, 916.46, ' которых потом будет вычисляться среднегодовое значение. Друзья, перед тем как порешать'], [916.46, 921.74, ' конкретные задачки на обработку массивов, давайте обсудим еще такой вопрос, как применимость'], [921.74, 927.86, ' знаний о массиве, да, ну и в целом навыков программирования на конкретных специальностях.'], [927.86, 933.86, ' Наиболее очевидный случай — это разработчик. Массивы являются достаточно простой и базовой'], [933.86, 939.5, ' структурой данных, с которой программисты знакомятся в первую очередь. После изучения'], [939.5, 945.26, ' массивов, а также получения навыков по их обработке, можно переходить к изучению таких'], [945.26, 951.1, ' структур данных, как стэк, очередь или же связанный список. Следующая специальность,'], [951.1, 955.98, ' где навыки работы с массивами не будут лишними — это тестировщик программного обеспечения.'], [955.98, 961.62, ' На старте профессии умение программировать, вероятно, вам не понадобится, особенно если'], [961.62, 967.0600000000001, ' речь идет о ручном тестировании. Однако, если вам понадобится освоить автоматизированное'], [967.0600000000001, 972.38, ' тестирование, то здесь уже, друзья, без навыков программирования не обойтись. В частности,'], [972.38, 978.34, ' понимание массивов, а также навыки работы с ними существенно ускорят изучение языка'], [978.34, 983.62, ' программирования высокого уровня. К специальностям аналитик, продукт, а также'], [983.62, 990.74, ' project manager высоких требований в плане владения конкретным языком программирования не предъявляется.'], [990.74, 995.98, ' Однако умение программировать, и в том числе навыки работы с массивами, будут достаточно'], [995.98, 1002.26, ' полезны аналитику, особенно если в круг его задач входит работа с большими объемами данных.'], [1002.26, 1007.7, ' Product и Project Manager, понимание основ программирования, будет достаточно полезно для'], [1007.7, 1014.6600000000001, ' взаимодействия с командой разработки, в частности, чтобы вести диалог с программистами на одном языке.'], [1014.6600000000001, 1021.1800000000001, ' Итак, друзья, давайте перейдем к первой задаче. В ней требуется заполнить массив целыми числами'], [1021.1800000000001, 1028.9, ' от 1 до n, где n — некоторое целое число, и вывести этот массив на экран. Давайте перечислим основные'], [1028.9, 1035.6200000000001, ' этапы в решении этой задачи, затем сформируем с вами блок-схему и запрограммируем на языке C-sharp.'], [1035.62, 1042.1, ' Первым шагом нам необходимо понять, а какой размер будет иметь создаваемый массив. Для этого,'], [1042.1, 1049.06, ' друзья, введем натуральное число n, после чего вторым шагом можем создать массив на n элементов,'], [1049.06, 1056.06, ' выделив под него память. Третьим этапом можно заполнить массив конкретными числами, после чего'], [1056.06, 1062.6999999999998, ' вывести его на экран. Для создания блок-схемы давайте вспомним задачу с предыдущего урока'], [1062.7, 1069.6200000000001, ' на вывод чисел от 1 до n. Друзья, обратите внимание, что эта задача очень похожа на текущую,'], [1069.6200000000001, 1076.6200000000001, ' поскольку в ней формируется число от 1 до n и затем выводится на экран. Давайте посмотрим,'], [1076.6200000000001, 1083.3400000000001, ' как можно модифицировать эту схему для решения нашей задачи. Первый этап у нас уже выполнен,'], [1083.3400000000001, 1090.66, ' ввод числа n в схеме уже присутствует. Добавим создание массива в блоке инициализации'], [1090.66, 1096.5800000000002, ' переменных до запуска цикла. Друзья, обратите внимание, что создание массива у меня выделено'], [1096.5800000000002, 1103.46, ' желтым цветом. И напомню вам, что под созданием массива мы понимаем выделение участка памяти'], [1103.46, 1111.3400000000001, ' для размещения элементов. Далее добавим основное действие, которое позволит заполнить массив. Для'], [1111.3400000000001, 1116.6200000000001, ' этого поместим значение счетчика на очередную позицию массива. Друзья, обратите внимание,'], [1117.02, 1123.82, ' что переменная счетчик изначально равна нулю, поэтому мы помещаем в массив число на единицу'], [1123.82, 1129.9399999999998, ' больше, то есть, как видно из схемы i плюс 1. Таким образом, друзья, в массив мы будем помещать'], [1129.9399999999998, 1137.82, ' числа 1, 2, 3 и так далее до числа n. Вывод элемента массива можно разместить в этом же цикле,'], [1137.82, 1145.3799999999999, ' но, друзья, сделать это нужно после помещения очередного значения в массив. Иначе мы будем'], [1145.38, 1152.46, ' выводить элементы массива до их формирования. Также отмечу, что вывод элементов можно сделать'], [1152.46, 1158.3400000000001, ' и в отдельном цикле. То есть, сначала у нас будет идти цикл по формированию элементов массива,'], [1158.3400000000001, 1165.3000000000002, ' и ниже точно такой же цикл для их вывода. Итак, наш блок схемы готова. Давайте посмотрим,'], [1165.3000000000002, 1173.8600000000001, ' как этот алгоритм будет выглядеть на языке C Sharp. Перейдем в каталог с заданием 2 и создадим'], [1173.86, 1185.86, ' там проект командой .NET New Console. Перейдем в файл с исходным кодом, удалим код сгенерированный'], [1185.86, 1192.74, ' по умолчанию и, согласно нашей блок схеме, создадим целочисленную переменную n равную 10.'], [1192.74, 1200.6999999999998, ' Друзья, поскольку число элементов в массиве заранее неизвестно, то мы будем пользоваться'], [1200.7, 1208.7, ' стандартным синтаксисом создания массива с указанием оператора New, типа данных и количества'], [1208.7, 1217.18, ' элементов, для которых мы будем создавать массив. Создадим переменную счетчик i изначально равную 0.'], [1217.18, 1224.98, ' Для заполнения и вывода мы используем цикл, поскольку будем повторять одни и те же действия,'], [1224.98, 1232.18, ' пока не дойдем до конца массива. Создадим цикл while с условием i строго меньше, чем количество'], [1232.18, 1245.22, ' элементов в массиве. В теле цикла сформируем очередной элемент массива i плюс 1 и поместим'], [1245.22, 1259.9, ' его на требуемую позицию в массиве R. Давайте выведем сразу его на экран с помощью инструкции.'], [1259.9, 1277.42, ' Друзья, чтобы элементы у нас не слипались при выводе, добавим пробел после каждого элемента.'], [1277.42, 1288.8600000000001, ' То есть продублируем инструкцию консоли в райд, только вместо элемента мы укажем символ пробела.'], [1289.9, 1300.74, ' И не забываем перейти к следующему значению счетчика путем увеличения его на единицу.'], [1300.74, 1312.0600000000002, ' Друзья, обратите внимание на вывод элементов на экран. Давайте оформим это более изящно и в одну'], [1312.06, 1321.86, ' строку. Воспользуемся средством C sharp, которое позволяет выводить на экран строку и помещать'], [1321.86, 1329.98, ' в нее переменную. Для этого воспользуемся все тем же методом консоли в райд. Только перед строкой'], [1329.98, 1337.5, ' мы поставим значок доллара и в самой строке значение очередного элемента массива array с'], [1337.98, 1348.26, ' index i. Поместим в фигурные скобки и добавим знак пробела. Друзья, в этом случае то, что было'], [1348.26, 1354.06, ' помещено в фигурные скобки будет рассматриваться как значение элемента массива или же, например,'], [1354.06, 1360.38, ' переменная и будет выведено на экран именно то, что находится в памяти, то есть сам элемент'], [1360.38, 1373.8200000000002, ' массива. Итак, давайте запустим наш код команды .NET Run. На экране мы видим приветственное сообщение'], [1373.8200000000002, 1383.0600000000002, ' Hello world. Однако, друзья, такого кода в файле до нашим программ.cs нет. Такая ситуация часто'], [1383.0600000000002, 1390.1000000000001, ' возникает, если мы забываем сохранить изменения в исходном файле. Давайте сохраним изменения'], [1390.1, 1403.26, ' путем нажатия комбинации клавиш Ctrl-S и запустим наш код еще раз. На экране мы видим последовательность'], [1403.26, 1412.02, ' чисел от 1 до 10. Следовательно, для этого набора элементов алгоритм работает верно. Друзья,'], [1412.02, 1417.82, ' обращу ваше внимание, что вместо использования переменной N, которая хранит количество элементов'], [1417.82, 1425.1, ' массива, мы можем воспользоваться свойством массива. Для этого обратимся по его имени,'], [1425.1, 1432.5, ' поставим точку и будет предложен набор методов и свойств, которыми располагает объект массив.'], [1432.5, 1440.46, ' Друзья, нам здесь из этого многообразия понадобится только свойство Lens, которое как раз-таки хранит'], [1440.46, 1449.3400000000001, ' количество элементов, под которые выделена память. То есть Lens в данном случае будет равен 10.'], [1449.3400000000001, 1454.98, ' Можно пользоваться как этим свойством, так же можно пользоваться и переменной.'], [1454.98, 1463.26, ' Друзья, давайте сделаем небольшую паузу, отдохнем от решения задач и рассмотрим два подхода к'], [1463.26, 1468.18, ' изучению программирования. Основная идея первого подхода заключается в постепенном повышении'], [1468.54, 1475.18, ' сложности решаемой задачи. Друзья, наше знакомство с языком C sharp мы начали с таких тематик,'], [1475.18, 1482.5, ' как переменные, типы данных, арифметика и затем перешли к условным и циклическим конструкциям.'], [1482.5, 1488.18, ' Друзья, рекомендую начинать знакомство с программированием, с решением базовых и простых задач.'], [1488.18, 1495.54, ' Например, нарешивать их некоторое количество, 5, 10, 15 штук и переходить к более сложным.'], [1495.54, 1503.34, ' Более сложные задачи очень часто являются комбинацией из набора простых задач. Друзья,'], [1503.34, 1508.82, ' не рекомендую сразу браться за сложные и комбинированные задачи, особенно если у'], [1508.82, 1516.1, ' вас возникают сложности на базовых задачах. Рассмотренный подход носит название от простого'], [1516.1, 1523.02, ' к сложному. Второй подход заключается в том, что количество решенных вами простых и базовых задач'], [1523.02, 1528.98, ' будет постепенно переходить в качество. То есть вы будете формировать свое алгоритмическое'], [1528.98, 1536.42, ' мышление, которое позволит вам решать более сложные задачи и строить более сложные алгоритмы.'], [1536.42, 1542.82, ' Таким образом, вы сможете опираться на некоторый фундамент из множества решенных'], [1542.82, 1549.74, ' вами базовых и простых задач. Двигаемся далее и давайте рассмотрим типовую задачу на поиск'], [1549.74, 1554.86, ' элементов в массиве, которые удовлетворяют некоторым условиям. Пусть у нас имеется массив'], [1554.86, 1561.14, ' на некоторое количество целых чисел, допустим на 10 штук. Требуется найти в нем четные числа'], [1561.14, 1568.46, ' и вывести их на экран. Друзья, напомню, что число является четным, если оно делится нацело на 2.'], [1568.46, 1575.9, ' Примеры четных чисел это 0, 2, 4, 6 и так далее. Давайте для этой задачи перечислим основные'], [1575.9, 1584.3000000000002, ' этапы, сформируем ее блок-схему и реализуем эту схему на языке C sharp. Итак, в этой задачи можно'], [1584.3000000000002, 1591.5400000000002, ' выделить следующие этапы. Первая, создать и заполнить массив на 10 целых чисел. Вторым этапом'], [1591.5400000000002, 1598.98, ' можно выделить проход по элементам, то есть просмотр каждого элемента. Третий этап это'], [1598.98, 1606.46, ' проверка элемента на условия того, является ли он четным. Ну и четвертый этап, друзья, это вывести'], [1606.46, 1613.38, ' этот элемент на экран, если указанное условие выполняется. Перейдем к блок-схеме. Обращу ваше'], [1613.38, 1619.3, ' внимание, друзья, что цикл прохода по элементам массива мы можем целиком взять из предыдущей'], [1619.3, 1625.66, ' задачи. Этот цикл будет одинаковым для всех задач, где требуется перебрать или же просмотреть'], [1625.66, 1632.1000000000001, ' элементы. Массив мы заполним с клавиатуры сразу же при его создании. Я обращу ваше внимание,'], [1632.1000000000001, 1638.6200000000001, ' что цикл в этом случае можно не использовать, поскольку число элементов заранее известно,'], [1638.6200000000001, 1645.46, ' напомню, их 10 штук и оно невелико. Далее цикл прохода по элементам массива нам необходимо'], [1645.46, 1650.22, ' добавить проверку очередного элемента на четность. Если же этого мы не будем делать,'], [1650.22, 1657.9, ' то на экран будут выведены все элементы, включая нечетные. Обратите внимание, условие разместил в'], [1657.9, 1666.66, ' блоке решения и написал там array с индексом i из even, что переводится как четный ли элемент с индексом i.'], [1666.66, 1675.46, ' Друзья, такая формулировка условия вполне подходит в использовании блок-схемы. Однако,'], [1675.46, 1681.22, ' при переносе блок-схемы на конкретный язык программирования могут возникнуть существенные'], [1681.22, 1686.74, ' сложности. Дело в том, что языкам программирования непонятно такая формулировка условия,'], [1686.74, 1692.98, ' которая вполне понятна человеку и допускается в использовании блок-схемы. Попытка перенести'], [1692.98, 1698.94, ' такое условие в язык программирования приведет к синтоксической ошибке. Друзья, к счастью,'], [1698.94, 1705.26, ' у этой проблемы есть решение и заключается оно в использовании операторов сравнения и'], [1705.26, 1712.54, ' арифметических операторов при построении условий. Эти операторы языки программирования вполне'], [1712.54, 1718.46, ' хорошо воспринимают. В данной задаче нам поможет оператор вычисления остатка отделения. Во многих'], [1718.46, 1723.6200000000001, ' современных языках программирования он обозначается либо с помощью значка процент,'], [1723.62, 1730.58, ' либо с помощью ключевого слова mod, что от английского в переводе с модула означает деление'], [1730.58, 1737.1799999999998, ' по модулю. И для проверки на равенство мы будем использовать двойной знак равно. И, друзья,'], [1737.1799999999998, 1743.4599999999998, ' напомню, что одинарный значок равно обозначает другую операцию. Итак, скорректируем наше условие'], [1743.4599999999998, 1750.1799999999998, ' и применим арифметический оператор остаток отделения и проверки на равенство. Есть остаток'], [1750.18, 1757.5800000000002, ' отделения. На два равен нулю. Это мы пишем в блоке решения. Он у меня подсвечен оранжевым цветом.'], [1757.5800000000002, 1764.5800000000002, ' То это значит, что очередной элемент массива делится на два нацело. То есть он четный и мы'], [1764.5800000000002, 1770.8600000000001, ' его будем выводить на экран ниже, друзья, с помощью блока вот вывод, который обозначается в виде'], [1770.8600000000001, 1778.02, ' параллограмма. В нем мы напишем то, что вывести очередной элемент массива array с индексом i.'], [1778.02, 1783.86, ' Итак, блок схемы нашего алгоритма готова. Давайте посмотрим, как он будет выглядеть на языке C-sharp.'], [1783.86, 1787.1399999999999, ' Перейдем в каталог задания 3 и создадим там проект.'], [1799.1399999999999, 1804.9, ' Перейдем в файл с исходным кодом. Удалим сгенерированный по умолчанию. Согласно нашей'], [1804.9, 1815.8200000000002, ' блок схеме создадим целочисленную переменную n равную 10 и массив на 10 целых чисел. Друзья,'], [1815.8200000000002, 1821.74, ' предлагаю использовать упрощенный синтакс создания массива, поскольку число элементов заранее'], [1821.74, 1834.38, ' известно и оно невелико. Создадим массив из 10 произвольных целых чисел, четных,'], [1834.38, 1842.6200000000001, ' а также добавим нечетные. Не забываем про форматирование кода.'], [1848.6200000000001, 1854.18, ' Создадим переменную счетчик i изначально равную нулю и оформим цикл while'], [1854.18, 1866.8600000000001, ' с условием счетчик строго меньше, чем количество элементов n. На каждой'], [1866.8600000000001, 1871.7, ' итерации будем проверять четность очередного элемента с помощью условной конструкции if.'], [1871.7, 1880.22, ' Обратимся к конкретному элементу по индексу i, разделим его с остатком на 2 и проверим,'], [1880.22, 1885.78, ' равен ли этот остаток нулю. Если это так, то значит, что элемент четный и нам нужно'], [1885.78, 1898.58, ' вывести его на экран. Давайте это сделаем с помощью метода write. Друзья, предлагаю использовать метод'], [1898.58, 1904.88, ' вывода переменной сразу же в строке. Напомню, используем символ доллара и затем в строке в'], [1904.88, 1911.48, ' фигурных скупочках пишем элемент, который хотим вывести на экран. В данном случае это'], [1911.48, 1922.8000000000002, ' просто очередной элемент массива и добавим пробел, чтобы элементы не слепались. Давайте запустим наш код.'], [1922.8, 1938.8799999999999, ' Друзья, на экране мы видим, что алгоритм у нас зациклился и значение первого элемента,'], [1938.8799999999999, 1946.82, ' да, 2-ка выводится в бесконечном цикле. Как вы думаете, почему так вышло? Я остановлю вывод'], [1946.82, 1954.74, ' комбинации клавишей CTRL-C. Друзья, все дело в том, что мы с вами забыли увеличить значение'], [1954.74, 1963.3, ' переменной i, да, то есть перейти к следующему элементу массива. Без этого мы будем обрабатывать'], [1963.3, 1969.9399999999998, ' каждый раз первый элемент массива и проверять его. То, что мы видим, то есть проверили, вывели,'], [1969.94, 1978.42, ' проверили, вылили и если не переходить к следующему элементу, то мы зациклим наш цикл i. Итак,'], [1978.42, 1986.78, ' сохраним изменения и запустим еще раз. На экране мы видим четные числа,'], [1986.78, 1995.46, ' которые являются элементами этого массива. Друзья, рекомендую проверить правильность работы этого'], [1995.46, 2002.54, ' алгоритма на различных входных данных. Например, массив можно задать целиком из четных чисел,'], [2002.54, 2008.38, ' да, из нечетных, ну или как в нашем случае из комбинации как четных, так и нечетных. Таким'], [2008.38, 2014.54, ' образом мы проверим работоспособность алгоритма на различных входных условиях. Итак, мы с вами'], [2014.54, 2021.26, " решили две типовые задачи на работу с массивами. Вспомнили, как в C-sharp'е обозначаются циклические"], [2021.26, 2026.98, ' конструкции условные, а также поработали с арифметикой и вводом-выводом. Друзья,'], [2026.98, 2033.14, ' давайте вспомним задачу из лекции введения в программирование, которая была связана с вычислением'], [2033.14, 2039.9, ' веса наиболее тяжелой гири. Напомню вам, как выглядит блок схемы для поиска наиболее тяжелой'], [2039.9, 2047.62, ' гири из 5 штук. Друзья, мы поочередно, как можете видеть, делаем 4 сравнения в блоках решения,'], [2047.62, 2055.46, ' и при необходимости, если эти сравнения дают нам ответ «Да», то по ветке «Yes», мы обновляем'], [2055.46, 2063.06, ' значение переменной «Max» в соответствующих блоках процесса. После проведения всех сравнений в'], [2063.06, 2069.8199999999997, ' переменной «Max» у нас будет находиться значение наиболее тяжелой гири. На предыдущей лекции мы'], [2069.8199999999997, 2076.74, ' с вами запрограммировали алгоритм для поиска наибольшего из 5 целых чисел. Мы с вами создали 5'], [2076.74, 2083.06, ' целочисленных переменных и разместили в них некоторые произвольные числа. Далее мы с вами'], [2083.06, 2090.2599999999998, ' сделали 4 сравнения с помощью оператора «if». Из-за счет этого мы нашли вес наиболее тяжелой гири,'], [2090.2599999999998, 2097.22, ' после чего в конце алгоритма мы вывели значение переменной «Max» на экран. Друзья, но как изменится'], [2097.22, 2104.1, ' этот алгоритм, если число гирь или же чисел будет увеличено? Предположим, что нам необходимо'], [2104.1, 2111.22, ' найти самую тяжелую гирю из количества 10 штук. Если оставить логику решения без изменений,'], [2111.22, 2116.94, ' то код может выглядеть примерно следующим образом. Обратите внимание, друзья, на количество'], [2116.94, 2124.2999999999997, ' переменных. Их здесь 10 штук и количество сравнений. Да, в целом задача решена, но код стал'], [2124.2999999999997, 2130.02, ' достаточно громовским и содержит большое количество повторяющихся инструкций. Давайте'], [2130.02, 2135.82, ' еще немного изменим условия нашей задачи и увеличим количество гирь, скажем, до 100 штук.'], [2135.82, 2142.62, ' Как можно видеть из фрагмента исходного кода, букв латинского алфавита для именования переменных'], [2142.62, 2149.02, ' мне не хватило, я начал использовать переменные из двух букв. Также можно давать имена следующие,'], [2149.02, 2154.82, ' да, «гиря1», «гиря2» и так далее. Но нужно использовать соответствующие английские слова,'], [2154.82, 2162.26, ' то есть «weight1», «weight2» и так далее. Друзья, если использовать эту же логику решения задачи,'], [2162.26, 2168.98, ' то для создания переменных у нас уйдет порядка 100 строк исходного кода, и нам нужно будет'], [2168.98, 2174.9, ' запрограммировать порядка 100 практически одинаковых инструкций сравнения с использованием оператора'], [2174.9, 2180.7000000000003, ' IF. Друзья, согласитесь, что для решения подобной задачи нам потребуется несколько иной подход.'], [2180.7, 2187.3399999999997, ' И одним из таких подходов мы можем рассмотреть использование массива для хранения весов,'], [2187.3399999999997, 2194.3399999999997, ' представленных гири. Сформулируем задачу в более общем виде. Дано n гирь, где n — некоторое'], [2194.3399999999997, 2200.4199999999996, ' натуральное число, и требуется найти наиболее тяжелую гирю. Вспомним алгоритм поиска,'], [2200.4199999999996, 2205.66, ' который был приведен в курсе «ведение в программировании», основанный на хранение весов'], [2205.66, 2212.2599999999998, ' гирь в массиве и использование цикла. Друзья, обратите внимание, что в этом алгоритме также'], [2212.2599999999998, 2219.8199999999997, ' используется переменная max и проводится n сравнений для определения гири наибольшего веса. Отличие'], [2219.8199999999997, 2225.46, ' этого алгоритма заключается в том, что в нем переменные хранятся не росыпью, как в приведенных'], [2225.46, 2233.3399999999997, ' ранее алгоритмах, а в упорядоченном контейнере, в массиве. А также, друзья, операция сравнения'], [2233.34, 2239.7400000000002, ' весов гири не повторяется в коде много раз, а участвует один раз и расположена в цикле.'], [2239.7400000000002, 2245.78, ' Отмечу, что этот алгоритм может быть применен для произвольного количества гири, как для пяти,'], [2245.78, 2251.1000000000004, ' для сотни, так и для тысячи штук. Итак, перейдем в каталог для четвертого задания.'], [2251.1000000000004, 2255.02, ' Также создадим там новый проект.'], [2255.02, 2272.2599999999998, ' Давайте возьмем количество гирь, равное, допустим, 5 штук.'], [2272.2599999999998, 2283.02, ' Создадим целочесленный массив из 5 весов гирь. Друзья, поскольку у нас количество весов небольшое,'], [2283.38, 2288.2599999999998, ' заранее известное, мы можем воспользоваться упрощенным синтаксисом создания массива.'], [2288.2599999999998, 2298.14, ' Создадим массив из набора произвольных различных чисел. Не забываем форматировать код.'], [2298.14, 2312.86, ' Далее создадим цикл while, который у нас пройдет по элементам массива, и перед этим мы создадим'], [2312.86, 2321.7400000000002, ' переменный счетчик, который будем использовать для условия цикла i меньше, чем количество элементов.'], [2321.7400000000002, 2329.26, ' Также мы эту перемену будем использовать при обращении к самим элементам. Друзья, для проверки,'], [2329.26, 2337.58, ' не превышает ли очередной элемент массива значение переменной max, мы напишем условия'], [2337.58, 2348.5, ' array с индексом i больше, чем переменная max. Ну и, конечно же, не забываем предварительно эту переменную'], [2348.5, 2358.9, ' создать. И проинцелизируем ее первым элементом массива, то есть элементом с индексом 0. Если это так,'], [2358.9, 2366.62, ' если очередной элемент у нас превысил текущее значение максимума, то мы обновим переменную max.'], [2366.62, 2376.98, ' Поместив в нее текущий элемент массива. Обращаю внимание, друзья, что в случае не выполнения до'], [2376.98, 2383.2999999999997, ' этого действия, этого условия, если оно неверно, то никакого отдельного действия для ветки lz не'], [2383.2999999999997, 2392.2999999999997, ' предусмотрено. Мы ее пропускаем. Не забываем перейти к следующему элементу массива, увеличив значение'], [2392.3, 2398.7000000000003, ' счетчика на единицу. И после завершения цикла выведем значение переменной max на экран,'], [2398.7000000000003, 2407.6600000000003, ' чтобы проверить правильность работы алгоритма. Сохраним изменения в исходном коде. Закустим наш'], [2407.6600000000003, 2418.54, ' код командой .NET RUN. Ожидаем убедить ответ 9, да, что соответствует наибольшему значению в этом массиве.'], [2418.54, 2425.18, ' Наши ожидания совпадают с выводом. Это говорит о том, что алгоритм работает правильно, друзья,'], [2425.18, 2431.18, ' для указанного набора данных. Друзья, также как и в предыдущей задаче, не забываем проверить'], [2431.18, 2437.22, ' правильность работы нашего алгоритма на различных входных данных. Применительно к этой задаче я бы'], [2437.22, 2444.34, ' рекомендовал проверить ее работоспособность на массиве, когда у нас наибольшее число находится в'], [2444.34, 2450.38, ' конце массива, в начале или же где-то посередине. Также лишним не будет проверить работу алгоритма,'], [2450.38, 2456.26, ' когда массив отсортирован по возрастанию или же наоборот по убыванию. Таким образом,'], [2456.26, 2463.1800000000003, ' вы проверите правильность его работы на различных начальных условиях. До настоящего момента мы с'], [2463.1800000000003, 2468.6200000000003, ' вами работали только с одной разновидностью циклов. Это VYLE. Давайте посмотрим, а какие еще'], [2468.62, 2474.62, ' способы создания циклической конструкции присутствуют в языке C-sharp. Друзья, на экране'], [2474.62, 2480.1, ' представлены блок схемы с использованием блока счетный цикл. Наверняка некоторые из вас при'], [2480.1, 2486.5, ' решении задач в курсе знакомства с программированием использовали этот блок. Большинство'], [2486.5, 2492.02, ' современных языков программирования поддерживают синтактис описания счетных циклов. Давайте'], [2492.02, 2498.5, ' посмотрим, как это выглядит в C-sharp. Итак, для создания счетного цикла используется ключевое'], [2498.5, 2505.7, ' слово for. Но в отличие от цикла VYLE, где в круговоскопах мы указываем только условия в цикле for,'], [2505.7, 2512.46, ' обратите внимание, также указывается создание переменной счетчика, в этом случае i равное нулю,'], [2512.46, 2519.78, ' и изменение этой переменной, то есть ее модификация i равно i плюс один. Друзья, давайте рассмотрим'], [2519.78, 2526.86, ' составные части цикла for более подробно. Первый блок это блок инициализации, то есть создание'], [2526.86, 2532.1400000000003, ' переменной счетчика и присвоение ей некоторого начального значения. В качестве имен переменных'], [2532.1400000000003, 2539.78, ' обычно используется i j k. Это стандартный подход при создании переменных счетчиков, будь то в цикле'], [2539.78, 2546.2200000000003, ' for, будь то в цикле VYLE. Второй блок это условия. Напомню, под условием мы понимаем выражение'], [2546.22, 2552.1, ' логического типа, на основании которого мы можем сказать верно оно или же нет. В данном случае,'], [2552.1, 2559.58, ' друзья, как и в цикле VYLE, на основании условия принимается решение, будет ли выполняться очередная'], [2559.58, 2565.7799999999997, ' итерация или же цикл закончится. Также отмечу то, что в условиях часто применяются операторы'], [2565.7799999999997, 2572.8999999999996, ' арифметики и операторы сравнения. Третья часть цикла это модификация, то есть изменение переменной'], [2572.9, 2579.38, ' счетчика. Переменная счетчика, как в этом примере, может расти с шагом на один, может расти с большим'], [2579.38, 2585.94, ' шагом 2, 3, 4, может умножаться, а также может уменьшаться. То есть будет конструкция i равно i'], [2585.94, 2592.46, ' минус 1. Ну и само собой тело цикла, которое располагается в фигурных скобках, то есть набор'], [2592.46, 2599.46, ' инструкций, которые будут выполняться на каждой его итерации. Друзья, для правильного применения'], [2599.86, 2607.7, ' цикла FOR крайне важно знать механизм или же алгоритм его работы. Давайте посмотрим, как работает цикл в приведенной'], [2607.7, 2615.02, ' примере. Итак, первым шагом выполняется блок инициализации. В данном случае переменная i присваивается'], [2615.02, 2621.7, ' значения 0. Вторым шагом, друзья, происходит проверка условия. То есть мы проверяем, меньше ли'], [2621.7, 2628.86, ' переменная i, чем число 10. Если это верно, то мы выполняем тело цикла, то есть те инструкции,'], [2628.86, 2636.6600000000003, ' которые заключены в фигурных скобках. Соответственно, после выполнения тела цикла происходит модификация. То есть'], [2636.6600000000003, 2643.54, ' то, что мы пишем с вами в теле цикла Вайлда. В этом случае i равно i плюс 1. Ну и пятый пункт — это'], [2643.54, 2649.54, ' возврат к пункту 2, то есть к проверке условий. То есть мы снова проверяем условия. Если оно верно,'], [2649.54, 2656.7400000000002, ' мы выполняем тело цикла. Если же оно неверно, мы цикл завершаем. Друзья, обращу ваше внимание,'], [2657.14, 2665.5, ' что точно таким же образом цикл FOR устроен в языках программирования C, C++, Java и PHP. Итак,'], [2665.5, 2672.2999999999997, ' на текущий момент мы знаем, что в C sharp используется две разновидности циклов — FOR и Вайл. Но как понять,'], [2672.2999999999997, 2677.8599999999997, ' какой из них применить к каждой конкретной задаче? Давайте, друзья, сформулируем некоторые'], [2677.8599999999997, 2683.66, ' рекомендации. И обращу внимание, что эти рекомендации не являются строгими правилами,'], [2683.66, 2690.8999999999996, ' но придерживаться их стоит. Цикл FOR мы часто используем, когда требуется перебрать элементы'], [2690.8999999999996, 2697.8199999999997, ' массива. Вывод на экран, да, как в этом примере. Или же подсчет суммы, подсчет среднего арифметического,'], [2697.8199999999997, 2703.62, ' или, допустим, поиск элементов по каким-либо критериям. Также цикл FOR может быть применен,'], [2703.62, 2710.42, ' когда верхняя граница числа итераций фиксирована, да, и известна до запуска программы. В данном'], [2710.42, 2718.1800000000003, ' примере суммируется числа от 1 до 100, и мы уверены, что число итераций здесь не превысит 100. В случае,'], [2718.1800000000003, 2724.58, ' когда нельзя заранее предсказать число итераций, или же когда нам неизвестно, да, верхняя их граница,'], [2724.58, 2730.94, ' то можем применять цикл Вайл. Давайте рассмотрим классический пример применения этого цикла при'], [2730.94, 2737.98, ' чтении файла по симульно. Пусть у нас имеется некоторый файл, который состоит из 27 символов.'], [2737.98, 2746.98, ' В зависимости от его кодировки, да, будь то ANSI, будь то UTF-8 или же Unicode, один символ может занимать 1,'], [2746.98, 2754.18, ' 2, 3 или даже 4 байта. Как вы можете видеть из строки состояния, которая указывается в нижней части'], [2754.18, 2761.86, ' блокнота, этот файл имеет кодировку UTF-8. То есть, один такой символ может иметь размер как 1,'], [2761.86, 2770.2200000000003, ' 2, так и 3 или 4 байта. Это зависит от того, является ли символ буквины цифровым или же представляет'], [2770.2200000000003, 2777.9, ' собой некоторую иконку, да, или же эмодзу. Обратите внимание, что размер этого файла равен 60 байтов,'], [2777.9, 2783.82, ' и зависимость от количества символов в нем не очевидна. То есть, нельзя сказать, что один символ'], [2783.82, 2790.6600000000003, ' занимает 1 байт или один символ занимает 2 байта, поскольку символов, я напомню, здесь 27. Поэтому,'], [2790.66, 2796.02, ' друзья, даже если мы знаем размер этого файла в байтах, мы заранее не можем предсказать, да,'], [2796.02, 2800.98, ' а сколько там будет храниться символов. Соответственно, мы не знаем, насколько'], [2800.98, 2807.94, ' итерации нам запускать цикл for. Как раз-таки здесь нам может быть полезен цикл while. В его условии'], [2807.94, 2813.94, ' можем написать ключевое слово true, что будет означать цикл бесконечный. В его действиях мы'], [2813.94, 2820.2599999999998, ' напишем чтение, да, очередного символа из файла, и вторым действием вывод этого символа на экран.'], [2820.26, 2826.46, ' Остановить этот цикл можно будет при достижении конца файла. Друзья, давайте рассмотрим третий'], [2826.46, 2832.82, ' способ организации цикла в C sharp. Это цикл for which. Для его создания мы используем ключевое слово'], [2832.82, 2840.1400000000003, ' for which. Далее в кулгускопках мы создаем переменную цикла с указанием ее типа данных. В данном случае,'], [2840.1400000000003, 2848.1800000000003, ' да, это целочисленный тип данных и имени. В этом примере имя у нее E. Друзья, важный момент.'], [2848.18, 2856.5, ' Тип данных у этой переменной должен совпадать с типом данных у элементов массива. Затем мы указываем'], [2856.5, 2863.02, ' ключевое слово in, да, от английского в, и указываем сам массив, элементы которого нам требуется'], [2863.02, 2869.8999999999996, ' перебрать. Работает цикл следующим образом. На каждой итерации в переменную цикла, в данном'], [2869.8999999999996, 2876.22, ' примере эта переменная E, помещается, а если быть точнее копируется очередной элемент массива.'], [2876.22, 2883.3399999999997, ' То есть на первой итерации в переменную E попадает единица, на второй итерации двойка и так далее,'], [2883.3399999999997, 2889.2999999999997, ' пока все элементы массива не будут перебраны. Этот цикл работает практически так же, как и цикл for,'], [2889.2999999999997, 2897.06, ' только в нем не используются индексы. Отмечу, что пара циклов for и while имеют принципиальные'], [2897.06, 2904.22, ' отличия от цикла for which в плане обращения к его элементам, а также возможности изменять эти'], [2904.22, 2910.2999999999997, ' элементы. Так вот, ключевое отличие заключается в том, что элементы в цикле for which они доступны'], [2910.2999999999997, 2916.9399999999996, ' только на чтение, то есть нет возможности их изменять. Достигается это за счет того, что элементы'], [2916.9399999999996, 2924.4199999999996, ' массива, да, каждый раз копируются, именно подчеркиваю, копируются в переменную циклу. Например,'], [2924.4199999999996, 2929.5, ' с помощью цикла for which мы можем вывести элементы на экран, как представлено в этом примере,'], [2929.5, 2935.02, ' посчитать их сумму или, например, среднеэлементическое. Кроме того, for which нам'], [2935.02, 2941.06, ' предоставляет возможность осуществить поиск каких-либо элементов. Друзья, важный момент,'], [2941.06, 2947.22, ' что попытка изменить содержимое элемента массива с помощью цикла for which, как здесь представлено'], [2947.22, 2954.5, ' в примере, приведет к ошибке. И большинство средств разработки, не исключение здесь является и'], [2954.5, 2962.58, ' visual studio code подчеркнут еще до этапа компиляции красным и как бы просигнализируют о том, что эта'], [2962.58, 2969.18, ' конструкция приведет к ошибке. Для лучшего понимания работы цикла for which давайте рассмотрим пример из'], [2969.18, 2976.5, ' реальной жизни. Приведем набор коробок с некоторым содержимым и будем считать этот набор массивом.'], [2976.5, 2983.7, ' Так вот, друзья, цикл for which позволяет нам заглянуть, проверить содержимое каждой коробки,'], [2983.7, 2990.8199999999997, ' то есть узнать характеристики этого содержимого, допустим, там вес, размер и так далее. Однако цикл'], [2990.8199999999997, 2997.4199999999996, ' for which не позволяет нам изменять содержимое коробок, удалять что-либо оттуда или добавлять новые'], [2997.4199999999996, 3003.7, ' предметы. Для подобных манипуляций нам необходимо использовать циклы for или же while, которые'], [3003.7, 3010.02, ' позволяют изменять содержимые элементов. Итак, давайте применим циклы for и for which к нашей'], [3010.02, 3017.38, ' задаче с гирями. Вернем переменную, которая хранит максимальное значение элементов массива в'], [3017.38, 3024.18, ' изначальное состояние, то есть присвоим ей значение первого элемента массива и давайте запустим цикл'], [3024.18, 3031.3, ' for. Напомню, первым шагом мы создаем переменную счетчик. Друзья, переменная счетчик i у нас уже'], [3031.3, 3037.7, ' задействована, поэтому давайте использовать другую, пускай это будет переменная счетчик j. Она равна нулю.'], [3037.7, 3044.9399999999996, ' Далее укажем условия цикла, она такой же будет, как и в цикле while. j меньше, чем число элементов'], [3044.9399999999996, 3055.18, ' n и, друзья, укажем изменение или же модификацию переменной счетчика. Друзья, обратите внимание,'], [3055.18, 3062.8199999999997, ' что я использую оператор increment. Возможно, вы ему уже пользовались. Он работает так же,'], [3062.82, 3072.6600000000003, ' как и конструкция j равно j плюс 1, только имеет более сокращенный вид. Прилагаю им пользоваться.'], [3072.6600000000003, 3078.1800000000003, ' Далее, как и в цикле while, оформляем тело в фигурных скобках. Тело можно скопировать'], [3078.1800000000003, 3085.02, ' целиком, поскольку у нас идет работа с индексами и тело никак не изменится. Единственное, что'], [3085.02, 3093.02, ' мы также скорректируем имя переменной счетчика. Друзья, и, конечно же, обратите внимание, что здесь'], [3093.02, 3101.94, ' нам не нужно дублировать модификацию счетчика, поскольку ее изменение заложено уже в самом цикле'], [3101.94, 3112.7, ' for. То есть эту строчку мы обязательно удаляем. Итак, проверим работоспособность нашего цикла for.'], [3112.7, 3125.06, ' Для этого выведем значение переменной максимум на экран. Перейдем в каталог задачи 4 и запустим'], [3125.06, 3138.7, ' там наш проект. На экране ожидаем увидеть дважды, да, 9 и 9. Ожидания совпадают с выводом. Также'], [3138.7, 3146.66, ' оформим решение с помощью цикла forage. Еще раз вернем значение переменной max в начальное состояние'], [3146.66, 3156.7799999999997, ' и запустим цикл forage. Напомню, он состоит из переменной цикла с типом данных, точно таким же,'], [3156.7799999999997, 3164.02, ' как и тип данных в элементе массива. В данном случае это целое число. Затем идет имя переменной,'], [3164.02, 3175.42, ' ключевое слово in и сам массив. Друзья, обращение по индексу в этом цикле уже не используется.'], [3175.42, 3181.06, ' Тело цикла мы можем скопировать, но необходимо сделать соответствующие замены. То есть таким'], [3181.06, 3185.98, ' образом обратиться к элементу массива мы не сможем, поскольку у нас здесь работа с индексами'], [3185.98, 3191.5, ' отсутствует. Мы с вами должны пользоваться переменной цикла. В данном случае это E.'], [3191.5, 3202.22, ' Укажем переменную E. Логика работы никак не меняется. Меняется способ обращения к элементу массива.'], [3202.22, 3218.4199999999996, ' Итак, выведем результат работы цикла на экран, запустим наш код, ожидаем увидеть также величину 9.'], [3218.4199999999996, 3225.14, ' Да, наши ожидания соответствуют выводу. Друзья, на этом практическая часть лекции заканчивается,'], [3225.14, 3230.9399999999996, ' и в заключение давайте обсудим, насколько нам нужен технический английский при разработке'], [3230.94, 3236.94, ' программ. При разработке программ обеспечения специалист зачастую сталкивается с терминологией'], [3236.94, 3243.38, ' на английском языке. Мы с вами в процессе решения задач, построения алгоритмов, блок схем часто'], [3243.38, 3250.02, ' сталкивались с терминологией на английском. Это были имена переменных, функции, а также сообщения'], [3250.02, 3256.5, ' об ошибках. Давайте резюмируем основные моменты, где знание английского будет для нас хорошим'], [3256.5, 3262.1, ' подспорьем. Первый аспект применения языка это именование объектов. Для лучшего восприятия'], [3262.1, 3267.94, ' исходного кода мы стараемся давать переменным, функциям и другим объектам, а смысленные имена,'], [3267.94, 3273.62, ' разумеется, на английском языке. В примере приведены три имени переменных с достаточно'], [3273.62, 3281.7, ' популярными названиями. Это цифра, да, от английского, digit, количество, amount и средняя average.'], [3281.7, 3289.3399999999997, ' Давайте забежим немного вперед и рассмотрим несколько примеров именований функций. Отмечу,'], [3289.3399999999997, 3296.4199999999996, ' что зачастую имена функций состоят из нескольких слов, одно из которых является глагол. Первая'], [3296.4199999999996, 3303.74, ' функция осуществляет чтение файла по некоторому пути, вторая пишет в журнал сообщения и третья'], [3303.74, 3309.62, ' сканирует директорию на предмет наличия интересующих файлов. Друзья, о функциях мы будем'], [3309.62, 3315.1, ' говорить подробнее на следующей лекции. Чтобы вести разработку программного обеспечения быстро и'], [3315.1, 3321.5, ' не обращаться к переводчику за именованием для каждой переменной, требуется пополнять свой'], [3321.5, 3326.74, ' словарный запас английскими техническими терминами. Следующий аспект, где английский может'], [3326.74, 3332.9, ' существенно нас выручить, это чтение ошибок, будь то от редактора Visual Studio Code, будь то'], [3332.9, 3339.54, ' сообщения об ошибках от компилятора или же, как в этом примере, да, от среды выполнения. Дело в'], [3339.54, 3346.34, ' том, что даже в русифицированных средах разработки сообщения об ошибках могут появляться на английском'], [3346.34, 3352.3, ' языке, связано то с тем, что далеко не все строки, не все сообщения имеют перевод на русский.'], [3352.3, 3358.46, ' Соответственно, знание английского языка поможет вам оперативно читать сообщения об ошибках,'], [3358.46, 3363.62, ' улавливать их суть и не прибегать к помощи переводчика. Здесь я уже не говорю о том,'], [3363.62, 3369.34, ' что большое число инструментов для разработки в принципе не имеют локализации на русском'], [3369.34, 3376.26, ' языке. Третий аспект применения английского — это поиск путей, да, способов решения возникающих'], [3376.26, 3382.3, ' проблем при разработке программного обеспечения. Давайте рассмотрим пример поиска информации о'], [3382.3, 3388.6600000000003, ' совместимости некоторого программного средства OpenSSL с операционной системой Windows 7. Друзья,'], [3388.6600000000003, 3394.6600000000003, ' подскажу, OpenSSL — это достаточно распространенный продукт, одно из направлений, в использовании'], [3394.66, 3401.42, ' которого — шифрование данных. Кому знакомы термины шифрование, криптография, можете написать об этом в чат.'], [3401.42, 3407.74, ' Так вот, обратите внимание, что попытка сформировать запрос на русском языке к явному ответу не приводит.'], [3407.74, 3415.18, ' Среди первых результатов в списке упоминания о средства OpenSSL отсутствует совсем. Я уже не говорю о'], [3415.18, 3421.7799999999997, ' том, насколько это средство совместимо с операционной системой Windows 7. Давайте рассмотрим результат'], [3421.78, 3428.98, ' поисковой выдачи, но при формировании запроса на английском языке. Как можете видеть, уже в первой'], [3428.98, 3434.6600000000003, ' ссылке находится наш вопрос о совместимости программных средств. Друзья, можете поверить'], [3434.6600000000003, 3440.7400000000002, ' мне на слово, что подобные ситуации встречаются достаточно часто. И на русскоязычных, будь то'], [3440.7400000000002, 3448.5800000000004, ' формах, порталах, иных ресурсах подходящая техническая информация может попросту отсутствовать,'], [3448.58, 3453.9, ' или же иметь неудовлетворительное качество. Ну и четвертый аспект применения английского,'], [3453.9, 3459.66, ' который я вынес на рассмотрение, это изучение технической документации. Документация у'], [3459.66, 3465.02, ' большинства инструментов разработки программного обеспечения изначально пишется на английском'], [3465.02, 3470.9, ' языке, и не всегда получается найти качественный перевод на русский. Да, здесь можно пользоваться'], [3470.9, 3476.2999999999997, ' переводчиками, в том числе автоматизированным переводом. Но, друзья, часто случается, что при'], [3476.3, 3482.38, ' автоматизированном переводе некоторые технические термины теряют свой смысл, да, или он искажается,'], [3482.38, 3488.1800000000003, ' и зачастую приходится обращаться к первоисточнику. Итак, друзья, мы с вами рассмотрели несколько'], [3488.1800000000003, 3493.54, ' важных аспектов применения технического английского языка. Но здесь может возникнуть вопрос,'], [3493.54, 3499.1800000000003, ' а с чего, собственно, начать изучение? Особенно, если ранее такого опыта у вас не было. Друзья,'], [3499.1800000000003, 3504.1800000000003, ' позвольте мне дать небольшую рекомендацию, выполнить которую большого труда не составит,'], [3504.18, 3509.94, ' но пользу от нее вы сможете получить достаточно быстро. Рекомендация эта достаточно нехитрая,'], [3509.94, 3515.8999999999996, ' да, и заключается она в ведении словаря или тетради с техническими терминами. То есть,'], [3515.8999999999996, 3521.62, ' если в процессе разработки, да, вам встречается тот или иной термин, будь то там от компилятора,'], [3521.62, 3528.2999999999997, ' будь то от среды разработки, будь то от сообщений среды выполнения, вы этот термин отмечаете себе'], [3528.3, 3533.82, ' в тетрадь или ваш конспект и снабжаете его переводом. Такой словарь, да, или тетрадь'], [3533.82, 3538.6200000000003, ' может получиться достаточно большим, поэтому чтобы эти термины откладывались в долговремную'], [3538.6200000000003, 3544.1000000000004, ' новую память, да, и вы их со временем запоминали, рекомендую этот конспект время от времени'], [3544.1000000000004, 3550.86, ' перечитывать. Таким образом, количество незнакомых терминов или же сообщений об ошибках, будь то в'], [3550.86, 3556.98, ' редакторе Visual Studio Code или же от платформы.net или же от среды исполнения будет сокращаться.'], [3556.98, 3563.66, ' Это вам позволит улавливать основной смысл сообщений об ошибках, давать именам и функциям более'], [3563.66, 3570.62, ' качественные названия, а также оперативно искать причины проблем в вашем коде. Ну что, друзья,'], [3570.62, 3576.82, ' на этом лекция о массивах подошла к концу. Давайте подведем ее основные итоги. Итак, в начале'], [3576.82, 3582.54, ' занятия мы с вами рассмотрели базовые определения, касающиеся массивов, рассмотрели их основные'], [3582.54, 3589.86, ' характеристики. После вводного экскурса мы с вами решили блок задач на базовую обработку массива,'], [3589.86, 3597.62, ' будь то создание, вывод на экран, заполнение, а также поиск элементов. Далее мы рассмотрели две'], [3597.62, 3604.7799999999997, ' разновидности циклов for и forage, а также обсудили особенности их применения на конкретных задачах.'], [3604.7799999999997, 3611.98, ' И в заключении, друзья, мы поговорили о важности изучения технического английского и пользы,'], [3611.98, 3616.78, ' которые от этого вы можете получить. На этом, друзья, я с вами прощаюсь. Благодарю вас за'], [3616.78, 3620.06, ' внимание. Увидимся на следующей лекции и на семинарах.']], 'text': " Друзья, привет! С вами снова я Денис. Рад вас приветствовать на лекции. Сегодня мы будем говорить о массивах. На прошлой лекции мы познакомились с языком программирования C-sharp, с его основными характеристиками, а также решили блок базовой задачи. На семинарах вы попрактиковались в разработке циклических условных конструкций, применяли арифметические операторы, а также операции водовывода. Сегодня мы вспомним основные понятия, связанные с массивами, их характеристики, поговорим о том, в каких задачах массивы могут применяться. Познакомимся, как осуществляется операция создания, заполнения, а также вывода массивов на экран и решим блок задач на их обработку. Ближе к концу лекции мы познакомимся с двумя разновидностями циклов FOR и FORGE, а также, друзья, поговорим о таком важном аспекте, как изучение английского для программистов. Друзья, перед тем как приступить к практике и начать решать задачи, давайте вспомним, а что из себя представляет массив и какими характеристиками он обладает. Начнем с ключевого термина этой лекции – массив. Массив представляет собой структуру данных, которая преднадачена для хранения элементов, как правило, одного типа. Массив может состоять из целых чисел, вещественных, может состоять из символов, а также, например, из строк. Если приводить примеры из реальной жизни, то массива мы можем назвать упорядоченный набор инструментов или же набор елочных игрушек, которые также обладают характеристикой упорядоченности. Второй важный термин – это индекс элемента массива. Друзья, этот термин можно сформулировать по-разному, приведем наиболее популярные формулировки. Итак, первое – это смещение элемента относительно начала массива, то есть насколько позиции элемент смещен относительно его левой границы. Ну и вторая формулировка, наиболее простая, это просто позиция элемента массива. Друзья, напомню, что в большинстве языков программирования индекс массива начинается с нуля. Перейдем к основным характеристикам массивов. Первая характеристика – это то, что массив должен иметь имя, еще его называют идентификатор. С помощью имени мы осуществляем обращение к элементам массива. Если нам нужно изменить элемент или же просто его прочитать, то мы используем операцию обращения к элементам по индексу. Также, друзья, эту операцию называют индексация. В большинстве языков программирования она обозначается с помощью пары квадратных скобок. В примере приведен массив из пяти элементов, и ниже вы можете видеть обращение к каждому его элементу с помощью оператора квадратной скобки. Отметим важную характеристику, которая определяет внутреннее устройство массивов. Друзья, элементы в массиве располагаются последовательно, то есть в памяти они занимают ячейку за ячейкой. Ни в коем случае элементы в массиве не расположены хаотично или же в каком-либо другом порядке. Ну и в заключение добавим, что массивы имеют конечный размер, поскольку объем памяти у нас всегда ограничен. Итак, после небольшого экскурса в теорию давайте посмотрим, как будут выглядеть основные операции при работе с массивами на языке C-sharp. Рассмотрим создание, заполнение и вывод массива на экран. В языке C-sharp создание массива состоит из трех основных этапов. Первый этап – это указание типа данных для элемента массива. Также, друзья, мы указываем оператор квадратной скобки, чтобы показать, что у нас именно создается массив, а не обычная переменная. Второй этап – это указание идентификатора или же имени массива. В данном примере, друзья, мы пользуемся именем R, что является сокращением от array. Друзья, рекомендую давать массивам осмысленные имена. В самом простом случае можно дать имя array, однако рекомендую задуматься над более осмысленным именованием. Как в пределных примерах, если вы оперируете набором файлов, то такой массив можно назвать именем files. Если же вы оперируете набором среднесуточных температур, то подобный массив можно назвать average dilated temperatures или сократить до average dilated temps. Но здесь важно не злоупотреблять сокращением в именовании переменных, особенно если эти имена становятся необщепринятыми и необщеизвестными. Имена array, R вполне допустимы для учебных задач, где мы делаем упор на демонстрацию той или иной техники по обработке массивов. То есть акцент делается не на конкретной предметной области. Следующий этап – это выделение памяти от элемента массива. На данном этапе мы указываем количество элементов, а также используем оператор new, который нам выделит фрагмент памяти для хранения будущих элементов. На этом три основные операции по созданию массива закончены, но также, друзья, можно выделить и четвертый этап. Он заключается в связывании участков памяти, который мы выделили с помощью оператора new с именем массива, с помощью оператора присваивания. Работать сегодня мы будем в каталоге урок 2. Друзья, иерархия каталогов на сегодня у меня уже создана. Перейдем в каталог с заданием 1 и создадим там проект, знакомый вам командой .NET New Console. Перейдем в файл с исходным кодом program.cs, удалим код, который сгенерировался по умолчанию. Итак, укажем тип данных массив целых чисел. Далее дадим массиву имя, например, и имя, который мы будем использовать для создания код. Друзья, если был бы у нас массив вещественных чисел, то в этом случае мы слева изменили и выделили их. И мы будем использовать их для создания код. Друзья, если вы хотите сделать такой массив, то вы можете сделать такой массив. Друзья, если был бы у нас массив вещественных чисел, то в этом случае мы слева от присваивания да и справа от присваивания использовали бы тип данных double или же float. Друзья, после выполнения данной операции у нас будет создан массив на 5 целых чисел. Обращаться к нему мы можем, используя его имя. Отмечу, что в языке C sharp элементы при создании массива имеют значение по умолчанию. Если это числовой массив, то элементами являются нули. Далее заполним массив произвольными целыми числами. Напомним, друзья, что для изменения элементов массива мы используем оператор индексации. И в квадратных скобках указываем индекс элемента. Заполним его произвольными целыми числами. Для ускорения можно скопировать эти конструкции. И не забываем менять индексы массива. В данном случае они у нас изменяются от нулевого и до размера массива минус 1. Сделаем элементы массива относительно случайными. Проверим, действительно ли массив заполнен. Для этого выведем каждый элемент на экран знакомым методом в WriteLine из модуля консолы. Для вывода элементов, для обращения мы также используем имя массива. И операция индексации с указанием индекса необходимого нам элемента. Для ускорения конструкцию вывода можно скопировать необходимое количество раз. Заменив индексы на соответствующих позициях. Друзья, выполним наш код с помощью команды .NETRUN. На экране мы видим значения которые были помещены в массив. Друзья, а как вы думаете, что произойдет если мы обратимся к элементу index.im. Вега oben находится значениеpielный и на экране построено значение mashed. Heaven,oles Neil у нас цKelly. И на экране мы видим значения которые были помещены в массив. А как вы думаете, что произойдет, если мы обратимся к элементу с индексом 5, при том, что количество элементов в массиве равно 5? Давайте это проверим и попробуем вывести на экран элемент с индексом равным 5. Итак, воспользуемся все тем же методом консоли Brightline и выведем на экран массив с индексом равным 5. Сохраним исходный код и запустим наш проект еще раз. Друзья, обратите внимание, что на экране у нас вывелась ошибка, связанная с выходом за границы массива. То есть таким образом среда выполнения предупреждает нас о том, что недопустимо обращаться за границы памяти, который мы выделили для массива. Закомментируем строчку с недопустимым обращением к массиву и давайте продолжим. Итак, друзья, мы создали массив на 5 элементов, заполнили его числами и вывели их на экран. Давайте рассмотрим способ заполнения массива сразу же при его создании. Для этого воспользуемся той же конструкцией, которую мы использовали, только с небольшим изменением. Все также будем создавать массив целочисленный. Дадим ему имя R2, поскольку имя R уже занято. И после указания имени выделим память на все те же 5 элементов, обязательно с указанием типа данных, и заполняем их произвольными целыми числами сразу же при создании этого массива. Друзья, напомню, что редактор Vizho Studio Code имеет инструменты форматирования кода. Для этого можно выделить необходимый участок, нажать правой кнопкой мыши и выбрать пункт меню формат документ или сочетание горячих клавиш shift alt f. Отмечу, что в C-sharp можно использовать упрощенный синтаксист для создания массива. Он заключается в том, что команду на выделение памяти, то есть new int и указание количества элементов, в некоторых случаях можно не использовать. Например, создадим целочисленный массив, дадим ему имя Ray3 и заполним его 5 целыми числами. Друзья, в этом случае команду на выделение памяти мы можем не использовать, поскольку число элементов у нас фиксировано и мы их указываем сразу при создании массива. Способ достаточно удобный для создания небольших массивов, когда заранее известные элементы. Друзья, отмечу, что, вероятно, знакомый многим из вас язык программирования Python имеет схожий синтаксис создания массива. Выглядит он примерно следующим образом. И также отмечу, что тип данных у массива мы не указываем. Не забываем, друзья, форматировать наш код, чтобы повысить его читаемость. Сохраним наши наработки в репозитории edit, проиндексируем целиком каталог task1, далее сформируем commit с указанием комментария о том, что мы добавили первую задачу в уроке 2 и отправим наши наработки на удаленный репозиторий. Друзья, перед тем как приступить к решению задач, давайте поговорим о том, а какие именно классы задач могут быть решены с помощью массивов, а также каким специальностям навыки работы с массивами и в целом знание о слов программирования будет полезным. Один из самых простых вариантов использования это хранение однотипных элементов и последующее обращение к ним. Например, в массиве мы можем сохранить набор целых чисел, чисел с плавающей точкой, символов или же набор строк, которые составляют некоторый текст. Также в массиве можем сохранить и более сложные объекты, например файлы. Массивы часто используются для поиска элементов по какому-либо критерию. Например, знакомый вам поиск минимального и максимального значения среди набора целых чисел. Если же рассмотреть набор строк в виде имен файлов как массив, то в таком массиве мы можем осуществить поиск графических файлов, файлов с видео содержимым или же, например, файлов с исходным кодом. В данном случае критерием будет расширение файла. Также отметим класс задач, в которых необходимо вычислить некоторую характеристику от всего набора элементов. Это может быть сумма значений, это может быть произведение или среднее значение. Друзья, в качестве примера можно рассмотреть вычисления суммарных затрат на предприятии. В таком массиве элементами могут быть затраты предприятия за день, за неделю или же, например, за месяц. Друзья, вопрос на засыпку. А как вы думаете, какой тип данных может быть у элементов в подобном массиве? Свои предположения можете написать в чат. Второй пример — это нахождение средней температуры за год. В таком массиве элементами могут быть значения температур за месяц, из которых потом будет вычисляться среднегодовое значение. Друзья, перед тем как порешать конкретные задачки на обработку массивов, давайте обсудим еще такой вопрос, как применимость знаний о массиве, да, ну и в целом навыков программирования на конкретных специальностях. Наиболее очевидный случай — это разработчик. Массивы являются достаточно простой и базовой структурой данных, с которой программисты знакомятся в первую очередь. После изучения массивов, а также получения навыков по их обработке, можно переходить к изучению таких структур данных, как стэк, очередь или же связанный список. Следующая специальность, где навыки работы с массивами не будут лишними — это тестировщик программного обеспечения. На старте профессии умение программировать, вероятно, вам не понадобится, особенно если речь идет о ручном тестировании. Однако, если вам понадобится освоить автоматизированное тестирование, то здесь уже, друзья, без навыков программирования не обойтись. В частности, понимание массивов, а также навыки работы с ними существенно ускорят изучение языка программирования высокого уровня. К специальностям аналитик, продукт, а также project manager высоких требований в плане владения конкретным языком программирования не предъявляется. Однако умение программировать, и в том числе навыки работы с массивами, будут достаточно полезны аналитику, особенно если в круг его задач входит работа с большими объемами данных. Product и Project Manager, понимание основ программирования, будет достаточно полезно для взаимодействия с командой разработки, в частности, чтобы вести диалог с программистами на одном языке. Итак, друзья, давайте перейдем к первой задаче. В ней требуется заполнить массив целыми числами от 1 до n, где n — некоторое целое число, и вывести этот массив на экран. Давайте перечислим основные этапы в решении этой задачи, затем сформируем с вами блок-схему и запрограммируем на языке C-sharp. Первым шагом нам необходимо понять, а какой размер будет иметь создаваемый массив. Для этого, друзья, введем натуральное число n, после чего вторым шагом можем создать массив на n элементов, выделив под него память. Третьим этапом можно заполнить массив конкретными числами, после чего вывести его на экран. Для создания блок-схемы давайте вспомним задачу с предыдущего урока на вывод чисел от 1 до n. Друзья, обратите внимание, что эта задача очень похожа на текущую, поскольку в ней формируется число от 1 до n и затем выводится на экран. Давайте посмотрим, как можно модифицировать эту схему для решения нашей задачи. Первый этап у нас уже выполнен, ввод числа n в схеме уже присутствует. Добавим создание массива в блоке инициализации переменных до запуска цикла. Друзья, обратите внимание, что создание массива у меня выделено желтым цветом. И напомню вам, что под созданием массива мы понимаем выделение участка памяти для размещения элементов. Далее добавим основное действие, которое позволит заполнить массив. Для этого поместим значение счетчика на очередную позицию массива. Друзья, обратите внимание, что переменная счетчик изначально равна нулю, поэтому мы помещаем в массив число на единицу больше, то есть, как видно из схемы i плюс 1. Таким образом, друзья, в массив мы будем помещать числа 1, 2, 3 и так далее до числа n. Вывод элемента массива можно разместить в этом же цикле, но, друзья, сделать это нужно после помещения очередного значения в массив. Иначе мы будем выводить элементы массива до их формирования. Также отмечу, что вывод элементов можно сделать и в отдельном цикле. То есть, сначала у нас будет идти цикл по формированию элементов массива, и ниже точно такой же цикл для их вывода. Итак, наш блок схемы готова. Давайте посмотрим, как этот алгоритм будет выглядеть на языке C Sharp. Перейдем в каталог с заданием 2 и создадим там проект командой .NET New Console. Перейдем в файл с исходным кодом, удалим код сгенерированный по умолчанию и, согласно нашей блок схеме, создадим целочисленную переменную n равную 10. Друзья, поскольку число элементов в массиве заранее неизвестно, то мы будем пользоваться стандартным синтаксисом создания массива с указанием оператора New, типа данных и количества элементов, для которых мы будем создавать массив. Создадим переменную счетчик i изначально равную 0. Для заполнения и вывода мы используем цикл, поскольку будем повторять одни и те же действия, пока не дойдем до конца массива. Создадим цикл while с условием i строго меньше, чем количество элементов в массиве. В теле цикла сформируем очередной элемент массива i плюс 1 и поместим его на требуемую позицию в массиве R. Давайте выведем сразу его на экран с помощью инструкции. Друзья, чтобы элементы у нас не слипались при выводе, добавим пробел после каждого элемента. То есть продублируем инструкцию консоли в райд, только вместо элемента мы укажем символ пробела. И не забываем перейти к следующему значению счетчика путем увеличения его на единицу. Друзья, обратите внимание на вывод элементов на экран. Давайте оформим это более изящно и в одну строку. Воспользуемся средством C sharp, которое позволяет выводить на экран строку и помещать в нее переменную. Для этого воспользуемся все тем же методом консоли в райд. Только перед строкой мы поставим значок доллара и в самой строке значение очередного элемента массива array с index i. Поместим в фигурные скобки и добавим знак пробела. Друзья, в этом случае то, что было помещено в фигурные скобки будет рассматриваться как значение элемента массива или же, например, переменная и будет выведено на экран именно то, что находится в памяти, то есть сам элемент массива. Итак, давайте запустим наш код команды .NET Run. На экране мы видим приветственное сообщение Hello world. Однако, друзья, такого кода в файле до нашим программ.cs нет. Такая ситуация часто возникает, если мы забываем сохранить изменения в исходном файле. Давайте сохраним изменения путем нажатия комбинации клавиш Ctrl-S и запустим наш код еще раз. На экране мы видим последовательность чисел от 1 до 10. Следовательно, для этого набора элементов алгоритм работает верно. Друзья, обращу ваше внимание, что вместо использования переменной N, которая хранит количество элементов массива, мы можем воспользоваться свойством массива. Для этого обратимся по его имени, поставим точку и будет предложен набор методов и свойств, которыми располагает объект массив. Друзья, нам здесь из этого многообразия понадобится только свойство Lens, которое как раз-таки хранит количество элементов, под которые выделена память. То есть Lens в данном случае будет равен 10. Можно пользоваться как этим свойством, так же можно пользоваться и переменной. Друзья, давайте сделаем небольшую паузу, отдохнем от решения задач и рассмотрим два подхода к изучению программирования. Основная идея первого подхода заключается в постепенном повышении сложности решаемой задачи. Друзья, наше знакомство с языком C sharp мы начали с таких тематик, как переменные, типы данных, арифметика и затем перешли к условным и циклическим конструкциям. Друзья, рекомендую начинать знакомство с программированием, с решением базовых и простых задач. Например, нарешивать их некоторое количество, 5, 10, 15 штук и переходить к более сложным. Более сложные задачи очень часто являются комбинацией из набора простых задач. Друзья, не рекомендую сразу браться за сложные и комбинированные задачи, особенно если у вас возникают сложности на базовых задачах. Рассмотренный подход носит название от простого к сложному. Второй подход заключается в том, что количество решенных вами простых и базовых задач будет постепенно переходить в качество. То есть вы будете формировать свое алгоритмическое мышление, которое позволит вам решать более сложные задачи и строить более сложные алгоритмы. Таким образом, вы сможете опираться на некоторый фундамент из множества решенных вами базовых и простых задач. Двигаемся далее и давайте рассмотрим типовую задачу на поиск элементов в массиве, которые удовлетворяют некоторым условиям. Пусть у нас имеется массив на некоторое количество целых чисел, допустим на 10 штук. Требуется найти в нем четные числа и вывести их на экран. Друзья, напомню, что число является четным, если оно делится нацело на 2. Примеры четных чисел это 0, 2, 4, 6 и так далее. Давайте для этой задачи перечислим основные этапы, сформируем ее блок-схему и реализуем эту схему на языке C sharp. Итак, в этой задачи можно выделить следующие этапы. Первая, создать и заполнить массив на 10 целых чисел. Вторым этапом можно выделить проход по элементам, то есть просмотр каждого элемента. Третий этап это проверка элемента на условия того, является ли он четным. Ну и четвертый этап, друзья, это вывести этот элемент на экран, если указанное условие выполняется. Перейдем к блок-схеме. Обращу ваше внимание, друзья, что цикл прохода по элементам массива мы можем целиком взять из предыдущей задачи. Этот цикл будет одинаковым для всех задач, где требуется перебрать или же просмотреть элементы. Массив мы заполним с клавиатуры сразу же при его создании. Я обращу ваше внимание, что цикл в этом случае можно не использовать, поскольку число элементов заранее известно, напомню, их 10 штук и оно невелико. Далее цикл прохода по элементам массива нам необходимо добавить проверку очередного элемента на четность. Если же этого мы не будем делать, то на экран будут выведены все элементы, включая нечетные. Обратите внимание, условие разместил в блоке решения и написал там array с индексом i из even, что переводится как четный ли элемент с индексом i. Друзья, такая формулировка условия вполне подходит в использовании блок-схемы. Однако, при переносе блок-схемы на конкретный язык программирования могут возникнуть существенные сложности. Дело в том, что языкам программирования непонятно такая формулировка условия, которая вполне понятна человеку и допускается в использовании блок-схемы. Попытка перенести такое условие в язык программирования приведет к синтоксической ошибке. Друзья, к счастью, у этой проблемы есть решение и заключается оно в использовании операторов сравнения и арифметических операторов при построении условий. Эти операторы языки программирования вполне хорошо воспринимают. В данной задаче нам поможет оператор вычисления остатка отделения. Во многих современных языках программирования он обозначается либо с помощью значка процент, либо с помощью ключевого слова mod, что от английского в переводе с модула означает деление по модулю. И для проверки на равенство мы будем использовать двойной знак равно. И, друзья, напомню, что одинарный значок равно обозначает другую операцию. Итак, скорректируем наше условие и применим арифметический оператор остаток отделения и проверки на равенство. Есть остаток отделения. На два равен нулю. Это мы пишем в блоке решения. Он у меня подсвечен оранжевым цветом. То это значит, что очередной элемент массива делится на два нацело. То есть он четный и мы его будем выводить на экран ниже, друзья, с помощью блока вот вывод, который обозначается в виде параллограмма. В нем мы напишем то, что вывести очередной элемент массива array с индексом i. Итак, блок схемы нашего алгоритма готова. Давайте посмотрим, как он будет выглядеть на языке C-sharp. Перейдем в каталог задания 3 и создадим там проект. Перейдем в файл с исходным кодом. Удалим сгенерированный по умолчанию. Согласно нашей блок схеме создадим целочисленную переменную n равную 10 и массив на 10 целых чисел. Друзья, предлагаю использовать упрощенный синтакс создания массива, поскольку число элементов заранее известно и оно невелико. Создадим массив из 10 произвольных целых чисел, четных, а также добавим нечетные. Не забываем про форматирование кода. Создадим переменную счетчик i изначально равную нулю и оформим цикл while с условием счетчик строго меньше, чем количество элементов n. На каждой итерации будем проверять четность очередного элемента с помощью условной конструкции if. Обратимся к конкретному элементу по индексу i, разделим его с остатком на 2 и проверим, равен ли этот остаток нулю. Если это так, то значит, что элемент четный и нам нужно вывести его на экран. Давайте это сделаем с помощью метода write. Друзья, предлагаю использовать метод вывода переменной сразу же в строке. Напомню, используем символ доллара и затем в строке в фигурных скупочках пишем элемент, который хотим вывести на экран. В данном случае это просто очередной элемент массива и добавим пробел, чтобы элементы не слепались. Давайте запустим наш код. Друзья, на экране мы видим, что алгоритм у нас зациклился и значение первого элемента, да, 2-ка выводится в бесконечном цикле. Как вы думаете, почему так вышло? Я остановлю вывод комбинации клавишей CTRL-C. Друзья, все дело в том, что мы с вами забыли увеличить значение переменной i, да, то есть перейти к следующему элементу массива. Без этого мы будем обрабатывать каждый раз первый элемент массива и проверять его. То, что мы видим, то есть проверили, вывели, проверили, вылили и если не переходить к следующему элементу, то мы зациклим наш цикл i. Итак, сохраним изменения и запустим еще раз. На экране мы видим четные числа, которые являются элементами этого массива. Друзья, рекомендую проверить правильность работы этого алгоритма на различных входных данных. Например, массив можно задать целиком из четных чисел, да, из нечетных, ну или как в нашем случае из комбинации как четных, так и нечетных. Таким образом мы проверим работоспособность алгоритма на различных входных условиях. Итак, мы с вами решили две типовые задачи на работу с массивами. Вспомнили, как в C-sharp'е обозначаются циклические конструкции условные, а также поработали с арифметикой и вводом-выводом. Друзья, давайте вспомним задачу из лекции введения в программирование, которая была связана с вычислением веса наиболее тяжелой гири. Напомню вам, как выглядит блок схемы для поиска наиболее тяжелой гири из 5 штук. Друзья, мы поочередно, как можете видеть, делаем 4 сравнения в блоках решения, и при необходимости, если эти сравнения дают нам ответ «Да», то по ветке «Yes», мы обновляем значение переменной «Max» в соответствующих блоках процесса. После проведения всех сравнений в переменной «Max» у нас будет находиться значение наиболее тяжелой гири. На предыдущей лекции мы с вами запрограммировали алгоритм для поиска наибольшего из 5 целых чисел. Мы с вами создали 5 целочисленных переменных и разместили в них некоторые произвольные числа. Далее мы с вами сделали 4 сравнения с помощью оператора «if». Из-за счет этого мы нашли вес наиболее тяжелой гири, после чего в конце алгоритма мы вывели значение переменной «Max» на экран. Друзья, но как изменится этот алгоритм, если число гирь или же чисел будет увеличено? Предположим, что нам необходимо найти самую тяжелую гирю из количества 10 штук. Если оставить логику решения без изменений, то код может выглядеть примерно следующим образом. Обратите внимание, друзья, на количество переменных. Их здесь 10 штук и количество сравнений. Да, в целом задача решена, но код стал достаточно громовским и содержит большое количество повторяющихся инструкций. Давайте еще немного изменим условия нашей задачи и увеличим количество гирь, скажем, до 100 штук. Как можно видеть из фрагмента исходного кода, букв латинского алфавита для именования переменных мне не хватило, я начал использовать переменные из двух букв. Также можно давать имена следующие, да, «гиря1», «гиря2» и так далее. Но нужно использовать соответствующие английские слова, то есть «weight1», «weight2» и так далее. Друзья, если использовать эту же логику решения задачи, то для создания переменных у нас уйдет порядка 100 строк исходного кода, и нам нужно будет запрограммировать порядка 100 практически одинаковых инструкций сравнения с использованием оператора IF. Друзья, согласитесь, что для решения подобной задачи нам потребуется несколько иной подход. И одним из таких подходов мы можем рассмотреть использование массива для хранения весов, представленных гири. Сформулируем задачу в более общем виде. Дано n гирь, где n — некоторое натуральное число, и требуется найти наиболее тяжелую гирю. Вспомним алгоритм поиска, который был приведен в курсе «ведение в программировании», основанный на хранение весов гирь в массиве и использование цикла. Друзья, обратите внимание, что в этом алгоритме также используется переменная max и проводится n сравнений для определения гири наибольшего веса. Отличие этого алгоритма заключается в том, что в нем переменные хранятся не росыпью, как в приведенных ранее алгоритмах, а в упорядоченном контейнере, в массиве. А также, друзья, операция сравнения весов гири не повторяется в коде много раз, а участвует один раз и расположена в цикле. Отмечу, что этот алгоритм может быть применен для произвольного количества гири, как для пяти, для сотни, так и для тысячи штук. Итак, перейдем в каталог для четвертого задания. Также создадим там новый проект. Давайте возьмем количество гирь, равное, допустим, 5 штук. Создадим целочесленный массив из 5 весов гирь. Друзья, поскольку у нас количество весов небольшое, заранее известное, мы можем воспользоваться упрощенным синтаксисом создания массива. Создадим массив из набора произвольных различных чисел. Не забываем форматировать код. Далее создадим цикл while, который у нас пройдет по элементам массива, и перед этим мы создадим переменный счетчик, который будем использовать для условия цикла i меньше, чем количество элементов. Также мы эту перемену будем использовать при обращении к самим элементам. Друзья, для проверки, не превышает ли очередной элемент массива значение переменной max, мы напишем условия array с индексом i больше, чем переменная max. Ну и, конечно же, не забываем предварительно эту переменную создать. И проинцелизируем ее первым элементом массива, то есть элементом с индексом 0. Если это так, если очередной элемент у нас превысил текущее значение максимума, то мы обновим переменную max. Поместив в нее текущий элемент массива. Обращаю внимание, друзья, что в случае не выполнения до этого действия, этого условия, если оно неверно, то никакого отдельного действия для ветки lz не предусмотрено. Мы ее пропускаем. Не забываем перейти к следующему элементу массива, увеличив значение счетчика на единицу. И после завершения цикла выведем значение переменной max на экран, чтобы проверить правильность работы алгоритма. Сохраним изменения в исходном коде. Закустим наш код командой .NET RUN. Ожидаем убедить ответ 9, да, что соответствует наибольшему значению в этом массиве. Наши ожидания совпадают с выводом. Это говорит о том, что алгоритм работает правильно, друзья, для указанного набора данных. Друзья, также как и в предыдущей задаче, не забываем проверить правильность работы нашего алгоритма на различных входных данных. Применительно к этой задаче я бы рекомендовал проверить ее работоспособность на массиве, когда у нас наибольшее число находится в конце массива, в начале или же где-то посередине. Также лишним не будет проверить работу алгоритма, когда массив отсортирован по возрастанию или же наоборот по убыванию. Таким образом, вы проверите правильность его работы на различных начальных условиях. До настоящего момента мы с вами работали только с одной разновидностью циклов. Это VYLE. Давайте посмотрим, а какие еще способы создания циклической конструкции присутствуют в языке C-sharp. Друзья, на экране представлены блок схемы с использованием блока счетный цикл. Наверняка некоторые из вас при решении задач в курсе знакомства с программированием использовали этот блок. Большинство современных языков программирования поддерживают синтактис описания счетных циклов. Давайте посмотрим, как это выглядит в C-sharp. Итак, для создания счетного цикла используется ключевое слово for. Но в отличие от цикла VYLE, где в круговоскопах мы указываем только условия в цикле for, обратите внимание, также указывается создание переменной счетчика, в этом случае i равное нулю, и изменение этой переменной, то есть ее модификация i равно i плюс один. Друзья, давайте рассмотрим составные части цикла for более подробно. Первый блок это блок инициализации, то есть создание переменной счетчика и присвоение ей некоторого начального значения. В качестве имен переменных обычно используется i j k. Это стандартный подход при создании переменных счетчиков, будь то в цикле for, будь то в цикле VYLE. Второй блок это условия. Напомню, под условием мы понимаем выражение логического типа, на основании которого мы можем сказать верно оно или же нет. В данном случае, друзья, как и в цикле VYLE, на основании условия принимается решение, будет ли выполняться очередная итерация или же цикл закончится. Также отмечу то, что в условиях часто применяются операторы арифметики и операторы сравнения. Третья часть цикла это модификация, то есть изменение переменной счетчика. Переменная счетчика, как в этом примере, может расти с шагом на один, может расти с большим шагом 2, 3, 4, может умножаться, а также может уменьшаться. То есть будет конструкция i равно i минус 1. Ну и само собой тело цикла, которое располагается в фигурных скобках, то есть набор инструкций, которые будут выполняться на каждой его итерации. Друзья, для правильного применения цикла FOR крайне важно знать механизм или же алгоритм его работы. Давайте посмотрим, как работает цикл в приведенной примере. Итак, первым шагом выполняется блок инициализации. В данном случае переменная i присваивается значения 0. Вторым шагом, друзья, происходит проверка условия. То есть мы проверяем, меньше ли переменная i, чем число 10. Если это верно, то мы выполняем тело цикла, то есть те инструкции, которые заключены в фигурных скобках. Соответственно, после выполнения тела цикла происходит модификация. То есть то, что мы пишем с вами в теле цикла Вайлда. В этом случае i равно i плюс 1. Ну и пятый пункт — это возврат к пункту 2, то есть к проверке условий. То есть мы снова проверяем условия. Если оно верно, мы выполняем тело цикла. Если же оно неверно, мы цикл завершаем. Друзья, обращу ваше внимание, что точно таким же образом цикл FOR устроен в языках программирования C, C++, Java и PHP. Итак, на текущий момент мы знаем, что в C sharp используется две разновидности циклов — FOR и Вайл. Но как понять, какой из них применить к каждой конкретной задаче? Давайте, друзья, сформулируем некоторые рекомендации. И обращу внимание, что эти рекомендации не являются строгими правилами, но придерживаться их стоит. Цикл FOR мы часто используем, когда требуется перебрать элементы массива. Вывод на экран, да, как в этом примере. Или же подсчет суммы, подсчет среднего арифметического, или, допустим, поиск элементов по каким-либо критериям. Также цикл FOR может быть применен, когда верхняя граница числа итераций фиксирована, да, и известна до запуска программы. В данном примере суммируется числа от 1 до 100, и мы уверены, что число итераций здесь не превысит 100. В случае, когда нельзя заранее предсказать число итераций, или же когда нам неизвестно, да, верхняя их граница, то можем применять цикл Вайл. Давайте рассмотрим классический пример применения этого цикла при чтении файла по симульно. Пусть у нас имеется некоторый файл, который состоит из 27 символов. В зависимости от его кодировки, да, будь то ANSI, будь то UTF-8 или же Unicode, один символ может занимать 1, 2, 3 или даже 4 байта. Как вы можете видеть из строки состояния, которая указывается в нижней части блокнота, этот файл имеет кодировку UTF-8. То есть, один такой символ может иметь размер как 1, 2, так и 3 или 4 байта. Это зависит от того, является ли символ буквины цифровым или же представляет собой некоторую иконку, да, или же эмодзу. Обратите внимание, что размер этого файла равен 60 байтов, и зависимость от количества символов в нем не очевидна. То есть, нельзя сказать, что один символ занимает 1 байт или один символ занимает 2 байта, поскольку символов, я напомню, здесь 27. Поэтому, друзья, даже если мы знаем размер этого файла в байтах, мы заранее не можем предсказать, да, а сколько там будет храниться символов. Соответственно, мы не знаем, насколько итерации нам запускать цикл for. Как раз-таки здесь нам может быть полезен цикл while. В его условии можем написать ключевое слово true, что будет означать цикл бесконечный. В его действиях мы напишем чтение, да, очередного символа из файла, и вторым действием вывод этого символа на экран. Остановить этот цикл можно будет при достижении конца файла. Друзья, давайте рассмотрим третий способ организации цикла в C sharp. Это цикл for which. Для его создания мы используем ключевое слово for which. Далее в кулгускопках мы создаем переменную цикла с указанием ее типа данных. В данном случае, да, это целочисленный тип данных и имени. В этом примере имя у нее E. Друзья, важный момент. Тип данных у этой переменной должен совпадать с типом данных у элементов массива. Затем мы указываем ключевое слово in, да, от английского в, и указываем сам массив, элементы которого нам требуется перебрать. Работает цикл следующим образом. На каждой итерации в переменную цикла, в данном примере эта переменная E, помещается, а если быть точнее копируется очередной элемент массива. То есть на первой итерации в переменную E попадает единица, на второй итерации двойка и так далее, пока все элементы массива не будут перебраны. Этот цикл работает практически так же, как и цикл for, только в нем не используются индексы. Отмечу, что пара циклов for и while имеют принципиальные отличия от цикла for which в плане обращения к его элементам, а также возможности изменять эти элементы. Так вот, ключевое отличие заключается в том, что элементы в цикле for which они доступны только на чтение, то есть нет возможности их изменять. Достигается это за счет того, что элементы массива, да, каждый раз копируются, именно подчеркиваю, копируются в переменную циклу. Например, с помощью цикла for which мы можем вывести элементы на экран, как представлено в этом примере, посчитать их сумму или, например, среднеэлементическое. Кроме того, for which нам предоставляет возможность осуществить поиск каких-либо элементов. Друзья, важный момент, что попытка изменить содержимое элемента массива с помощью цикла for which, как здесь представлено в примере, приведет к ошибке. И большинство средств разработки, не исключение здесь является и visual studio code подчеркнут еще до этапа компиляции красным и как бы просигнализируют о том, что эта конструкция приведет к ошибке. Для лучшего понимания работы цикла for which давайте рассмотрим пример из реальной жизни. Приведем набор коробок с некоторым содержимым и будем считать этот набор массивом. Так вот, друзья, цикл for which позволяет нам заглянуть, проверить содержимое каждой коробки, то есть узнать характеристики этого содержимого, допустим, там вес, размер и так далее. Однако цикл for which не позволяет нам изменять содержимое коробок, удалять что-либо оттуда или добавлять новые предметы. Для подобных манипуляций нам необходимо использовать циклы for или же while, которые позволяют изменять содержимые элементов. Итак, давайте применим циклы for и for which к нашей задаче с гирями. Вернем переменную, которая хранит максимальное значение элементов массива в изначальное состояние, то есть присвоим ей значение первого элемента массива и давайте запустим цикл for. Напомню, первым шагом мы создаем переменную счетчик. Друзья, переменная счетчик i у нас уже задействована, поэтому давайте использовать другую, пускай это будет переменная счетчик j. Она равна нулю. Далее укажем условия цикла, она такой же будет, как и в цикле while. j меньше, чем число элементов n и, друзья, укажем изменение или же модификацию переменной счетчика. Друзья, обратите внимание, что я использую оператор increment. Возможно, вы ему уже пользовались. Он работает так же, как и конструкция j равно j плюс 1, только имеет более сокращенный вид. Прилагаю им пользоваться. Далее, как и в цикле while, оформляем тело в фигурных скобках. Тело можно скопировать целиком, поскольку у нас идет работа с индексами и тело никак не изменится. Единственное, что мы также скорректируем имя переменной счетчика. Друзья, и, конечно же, обратите внимание, что здесь нам не нужно дублировать модификацию счетчика, поскольку ее изменение заложено уже в самом цикле for. То есть эту строчку мы обязательно удаляем. Итак, проверим работоспособность нашего цикла for. Для этого выведем значение переменной максимум на экран. Перейдем в каталог задачи 4 и запустим там наш проект. На экране ожидаем увидеть дважды, да, 9 и 9. Ожидания совпадают с выводом. Также оформим решение с помощью цикла forage. Еще раз вернем значение переменной max в начальное состояние и запустим цикл forage. Напомню, он состоит из переменной цикла с типом данных, точно таким же, как и тип данных в элементе массива. В данном случае это целое число. Затем идет имя переменной, ключевое слово in и сам массив. Друзья, обращение по индексу в этом цикле уже не используется. Тело цикла мы можем скопировать, но необходимо сделать соответствующие замены. То есть таким образом обратиться к элементу массива мы не сможем, поскольку у нас здесь работа с индексами отсутствует. Мы с вами должны пользоваться переменной цикла. В данном случае это E. Укажем переменную E. Логика работы никак не меняется. Меняется способ обращения к элементу массива. Итак, выведем результат работы цикла на экран, запустим наш код, ожидаем увидеть также величину 9. Да, наши ожидания соответствуют выводу. Друзья, на этом практическая часть лекции заканчивается, и в заключение давайте обсудим, насколько нам нужен технический английский при разработке программ. При разработке программ обеспечения специалист зачастую сталкивается с терминологией на английском языке. Мы с вами в процессе решения задач, построения алгоритмов, блок схем часто сталкивались с терминологией на английском. Это были имена переменных, функции, а также сообщения об ошибках. Давайте резюмируем основные моменты, где знание английского будет для нас хорошим подспорьем. Первый аспект применения языка это именование объектов. Для лучшего восприятия исходного кода мы стараемся давать переменным, функциям и другим объектам, а смысленные имена, разумеется, на английском языке. В примере приведены три имени переменных с достаточно популярными названиями. Это цифра, да, от английского, digit, количество, amount и средняя average. Давайте забежим немного вперед и рассмотрим несколько примеров именований функций. Отмечу, что зачастую имена функций состоят из нескольких слов, одно из которых является глагол. Первая функция осуществляет чтение файла по некоторому пути, вторая пишет в журнал сообщения и третья сканирует директорию на предмет наличия интересующих файлов. Друзья, о функциях мы будем говорить подробнее на следующей лекции. Чтобы вести разработку программного обеспечения быстро и не обращаться к переводчику за именованием для каждой переменной, требуется пополнять свой словарный запас английскими техническими терминами. Следующий аспект, где английский может существенно нас выручить, это чтение ошибок, будь то от редактора Visual Studio Code, будь то сообщения об ошибках от компилятора или же, как в этом примере, да, от среды выполнения. Дело в том, что даже в русифицированных средах разработки сообщения об ошибках могут появляться на английском языке, связано то с тем, что далеко не все строки, не все сообщения имеют перевод на русский. Соответственно, знание английского языка поможет вам оперативно читать сообщения об ошибках, улавливать их суть и не прибегать к помощи переводчика. Здесь я уже не говорю о том, что большое число инструментов для разработки в принципе не имеют локализации на русском языке. Третий аспект применения английского — это поиск путей, да, способов решения возникающих проблем при разработке программного обеспечения. Давайте рассмотрим пример поиска информации о совместимости некоторого программного средства OpenSSL с операционной системой Windows 7. Друзья, подскажу, OpenSSL — это достаточно распространенный продукт, одно из направлений, в использовании которого — шифрование данных. Кому знакомы термины шифрование, криптография, можете написать об этом в чат. Так вот, обратите внимание, что попытка сформировать запрос на русском языке к явному ответу не приводит. Среди первых результатов в списке упоминания о средства OpenSSL отсутствует совсем. Я уже не говорю о том, насколько это средство совместимо с операционной системой Windows 7. Давайте рассмотрим результат поисковой выдачи, но при формировании запроса на английском языке. Как можете видеть, уже в первой ссылке находится наш вопрос о совместимости программных средств. Друзья, можете поверить мне на слово, что подобные ситуации встречаются достаточно часто. И на русскоязычных, будь то формах, порталах, иных ресурсах подходящая техническая информация может попросту отсутствовать, или же иметь неудовлетворительное качество. Ну и четвертый аспект применения английского, который я вынес на рассмотрение, это изучение технической документации. Документация у большинства инструментов разработки программного обеспечения изначально пишется на английском языке, и не всегда получается найти качественный перевод на русский. Да, здесь можно пользоваться переводчиками, в том числе автоматизированным переводом. Но, друзья, часто случается, что при автоматизированном переводе некоторые технические термины теряют свой смысл, да, или он искажается, и зачастую приходится обращаться к первоисточнику. Итак, друзья, мы с вами рассмотрели несколько важных аспектов применения технического английского языка. Но здесь может возникнуть вопрос, а с чего, собственно, начать изучение? Особенно, если ранее такого опыта у вас не было. Друзья, позвольте мне дать небольшую рекомендацию, выполнить которую большого труда не составит, но пользу от нее вы сможете получить достаточно быстро. Рекомендация эта достаточно нехитрая, да, и заключается она в ведении словаря или тетради с техническими терминами. То есть, если в процессе разработки, да, вам встречается тот или иной термин, будь то там от компилятора, будь то от среды разработки, будь то от сообщений среды выполнения, вы этот термин отмечаете себе в тетрадь или ваш конспект и снабжаете его переводом. Такой словарь, да, или тетрадь может получиться достаточно большим, поэтому чтобы эти термины откладывались в долговремную новую память, да, и вы их со временем запоминали, рекомендую этот конспект время от времени перечитывать. Таким образом, количество незнакомых терминов или же сообщений об ошибках, будь то в редакторе Visual Studio Code или же от платформы.net или же от среды исполнения будет сокращаться. Это вам позволит улавливать основной смысл сообщений об ошибках, давать именам и функциям более качественные названия, а также оперативно искать причины проблем в вашем коде. Ну что, друзья, на этом лекция о массивах подошла к концу. Давайте подведем ее основные итоги. Итак, в начале занятия мы с вами рассмотрели базовые определения, касающиеся массивов, рассмотрели их основные характеристики. После вводного экскурса мы с вами решили блок задач на базовую обработку массива, будь то создание, вывод на экран, заполнение, а также поиск элементов. Далее мы рассмотрели две разновидности циклов for и forage, а также обсудили особенности их применения на конкретных задачах. И в заключении, друзья, мы поговорили о важности изучения технического английского и пользы, которые от этого вы можете получить. На этом, друзья, я с вами прощаюсь. Благодарю вас за внимание. Увидимся на следующей лекции и на семинарах."}
